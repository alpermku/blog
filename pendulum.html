<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double Pendulum - Alex Yalın</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/jpeg" href="assets/avatar.jpg">
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #050505; color: #eee; }
        canvas { display: block; }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .overlay h1 {
            font-family: 'Inter', sans-serif;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .overlay p {
            font-family: 'Lora', serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin: 5px 0 0 0;
        }
        .back-link {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.3s;
            pointer-events: auto;
        }
        .back-link:hover {
            color: #fff;
            border-bottom-color: #fff;
        }
    </style>
</head>
<body>
    <div class="overlay">
        <h1>Double Pendulum</h1>
        <p>Simple physics, complex outcome.</p>
    </div>
    
    <a href="gallery.html" class="back-link">&larr; Back to Gallery</a>

    <canvas id="pendulumCanvas"></canvas>

    <script>
        const canvas = document.getElementById('pendulumCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        
        // Fizik Değişkenleri
        let r1 = 150; // Kol 1 uzunluğu
        let r2 = 150; // Kol 2 uzunluğu
        let m1 = 20;  // Kütle 1
        let m2 = 20;  // Kütle 2
        let a1 = Math.PI / 2; // Açı 1
        let a2 = Math.PI / 2; // Açı 2
        let a1_v = 0; // Açısal Hız 1
        let a2_v = 0; // Açısal Hız 2
        let g = 1;    // Yerçekimi

        let path = [];
        let prevX, prevY;

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            // Random başlangıç
            a1 = Math.random() * Math.PI * 2;
            a2 = Math.random() * Math.PI * 2;
            a1_v = 0;
            a2_v = 0;
            
            path = [];
            
            // Temizle
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);
        }

        function draw() {
            // Arka planı çok hafif sil (uzun izler kalsın)
            // Ama sarkacın kendisini her karede silip tekrar çizmek lazım.
            // Bu yüzden "iz"i ayrı bir katman (offscreen canvas) veya path array'i olarak tutmak daha iyi.
            // Performans için basitçe "fade out" efekti kullanalım:
            
            // ctx.fillStyle = 'rgba(5, 5, 5, 0.02)';
            // ctx.fillRect(0, 0, width, height);
            
            // HAYIR, kullanıcının istediği "kaos"u görmek için izlerin kalıcı olması daha iyi.
            // Sadece sarkacın kollarını (çubuklarını) siliyoruz? Hayır, o zaman izler de silinir.
            // Çözüm: İzleri kalıcı çiziyoruz, kolları ise her karede çizip siliyoruz?
            // Basitlik: Kolları çizmeyelim, sadece uç noktanın izini çizelim. (Harmonograf gibi).
            // Ya da kolları çok silik çizelim.
            
            // Formüller (Lagrangian Mechanics)
            let num1 = -g * (2 * m1 + m2) * Math.sin(a1);
            let num2 = -m2 * g * Math.sin(a1 - 2 * a2);
            let num3 = -2 * Math.sin(a1 - a2) * m2;
            let num4 = a2_v * a2_v * r2 + a1_v * a1_v * r1 * Math.cos(a1 - a2);
            let den = r1 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
            let a1_a = (num1 + num2 + num3 * num4) / den;

            num1 = 2 * Math.sin(a1 - a2);
            num2 = (a1_v * a1_v * r1 * (m1 + m2));
            num3 = g * (m1 + m2) * Math.cos(a1);
            num4 = a2_v * a2_v * r2 * m2 * Math.cos(a1 - a2);
            den = r2 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
            let a2_a = (num1 * (num2 + num3 + num4)) / den;

            a1_v += a1_a;
            a2_v += a2_a;
            a1 += a1_v;
            a2 += a2_v;
            
            // Sürtünme (Damping) - Sonsuza kadar dönmesin, ama uzun sürsün
            // a1_v *= 0.999;
            // a2_v *= 0.999;

            // Pozisyonlar
            let x1 = width / 2 + r1 * Math.sin(a1);
            let y1 = height / 3 + r1 * Math.cos(a1);

            let x2 = x1 + r2 * Math.sin(a2);
            let y2 = y1 + r2 * Math.cos(a2);

            // Çizim (İz)
            // Renk hıza göre değişsin
            const speed = Math.abs(a1_v + a2_v);
            const hue = (speed * 1000) % 360; 
            
            ctx.beginPath();
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.5)`;
            ctx.lineWidth = 2;
            if (prevX) {
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            prevX = x2;
            prevY = y2;

            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', init);
        init();
        draw();
    </script>
</body>
</html>