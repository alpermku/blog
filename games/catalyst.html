<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Catalyst - Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#06060f;overflow:hidden;font-family:'JetBrains Mono',monospace;color:#fff;user-select:none;display:flex;justify-content:center;align-items:center;height:100vh;flex-direction:column}
        canvas{border:2px solid rgba(255,140,0,0.2);border-radius:4px;box-shadow:0 0 60px rgba(255,140,0,0.05);cursor:crosshair}
        .back-btn{position:fixed;top:14px;left:18px;z-index:20;font-family:'JetBrains Mono',monospace;font-size:13px;color:rgba(255,255,255,0.35);text-decoration:none;transition:color .2s}
        .back-btn:hover{color:#fff}
        .ui{position:fixed;z-index:10;pointer-events:none;width:100%;height:100%}
        .hud{position:absolute;top:14px;left:50%;transform:translateX(-50%);display:flex;gap:18px;align-items:center}
        .hud-item{font-family:'Press Start 2P',cursive;font-size:10px}
        .hud-title{color:#ff8c00;font-size:12px;text-shadow:0 0 10px rgba(255,140,0,0.5)}
        .hud-score{color:#fff}
        .hud-level{color:#44ffaa}
        .hud-clicks{color:#00c8ff}
        .hud-stars{color:#ffd700;font-size:12px}
        #overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:30;pointer-events:all;background:rgba(6,6,15,0.94)}
        #overlay.hidden{display:none}
        #overlay h1{font-family:'Press Start 2P',cursive;font-size:24px;color:#ff8c00;text-shadow:0 0 30px rgba(255,140,0,0.4);margin-bottom:16px}
        #overlay h2{font-family:'Press Start 2P',cursive;font-size:16px;color:#fff;margin-bottom:12px}
        #overlay p{font-size:12px;color:rgba(255,255,255,0.55);max-width:520px;text-align:center;line-height:2;margin-bottom:6px}
        #overlay .stars-display{font-size:32px;margin:14px 0}
        #overlay .btn{font-family:'Press Start 2P',cursive;font-size:11px;color:#06060f;background:#ff8c00;border:none;padding:14px 28px;border-radius:6px;cursor:pointer;margin-top:14px;transition:all .2s;pointer-events:all}
        #overlay .btn:hover{background:#ffaa33;transform:scale(1.05)}
        #overlay .btn-secondary{background:transparent;color:#ff8c00;border:2px solid #ff8c00}
        #overlay .btn-secondary:hover{background:rgba(255,140,0,0.1)}
        .level-select{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin:16px 0}
        .level-btn{font-family:'Press Start 2P',cursive;font-size:10px;padding:12px 8px;background:rgba(255,255,255,0.05);border:2px solid rgba(255,255,255,0.1);border-radius:6px;color:#fff;cursor:pointer;text-align:center;transition:all .2s;pointer-events:all}
        .level-btn:hover{border-color:#ff8c00;background:rgba(255,140,0,0.1)}
        .level-btn.locked{opacity:0.3;cursor:not-allowed;pointer-events:none}
        .level-btn .lvl-stars{font-size:8px;display:block;margin-top:4px;color:#ffd700}
        .achievements{position:fixed;top:50px;right:20px;z-index:25;display:flex;flex-direction:column;gap:8px}
        .achievement{font-family:'Press Start 2P',cursive;font-size:8px;background:rgba(255,215,0,0.15);border:1px solid #ffd700;color:#ffd700;padding:8px 14px;border-radius:4px;animation:achieveIn .5s ease-out,achieveOut .5s ease-in 3s forwards;white-space:nowrap}
        @keyframes achieveIn{from{transform:translateX(100px);opacity:0}to{transform:translateX(0);opacity:1}}
        @keyframes achieveOut{to{transform:translateX(100px);opacity:0}}
        .stat-row{display:flex;gap:30px;margin:6px 0;align-items:center;justify-content:center}
        .stat-label{font-family:'Press Start 2P',cursive;font-size:8px;color:rgba(255,255,255,0.4)}
        .stat-value{font-family:'Press Start 2P',cursive;font-size:11px;color:#fff}
        .tip{font-size:10px;color:rgba(255,255,255,0.3);margin-top:10px;font-style:italic}
    </style>
</head>
<body>
    <a href="../games.html" class="back-btn">‚Üê Arcade</a>
    <div class="ui">
        <div class="hud">
            <span class="hud-item hud-title">CATALYST</span>
            <span class="hud-item hud-score" id="hScore">0</span>
            <span class="hud-item hud-level" id="hLevel">LV 1</span>
            <span class="hud-item hud-clicks" id="hClicks">‚óè ‚óè</span>
            <span class="hud-item hud-stars" id="hStars"></span>
        </div>
    </div>
    <div id="overlay">
        <h1>CATALYST</h1>
        <p>üéØ Click near clusters of particles to start a chain reaction.<br>
        üí• Each detonated particle explodes and triggers nearby ones.<br>
        ‚≠ê Detonate enough to earn stars and unlock the next level.</p>
        <p class="tip">TIP: Wait for particles to cluster together, then strike!</p>
        <button class="btn" onclick="startGame()">START</button>
    </div>
    <div class="achievements" id="achievements"></div>
    <canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const achieveBox = document.getElementById('achievements');

const W = Math.min(window.innerWidth - 20, 850);
const H = Math.min(window.innerHeight - 20, 620);
canvas.width = W; canvas.height = H;

// ======================== LEVEL DATA ========================
// Key tuning: generous radii + clustered spawns = satisfying chains
const LEVELS = [
    { particles: 20, clicks: 2, target3: 0.80, target2: 0.60, target1: 0.35, speed: 0.3, blastR: 75,  types: ['normal'],                          name: 'SPARK',     tip: 'Click where particles cluster!' },
    { particles: 28, clicks: 2, target3: 0.75, target2: 0.55, target1: 0.30, speed: 0.4, blastR: 72,  types: ['normal'],                          name: 'KINDLE',    tip: 'Timing matters ‚Äî wait for groups.' },
    { particles: 35, clicks: 2, target3: 0.72, target2: 0.50, target1: 0.28, speed: 0.5, blastR: 70,  types: ['normal','mega'],                   name: 'IGNITE',    tip: 'Red MEGA particles have bigger blasts!' },
    { particles: 40, clicks: 3, target3: 0.75, target2: 0.55, target1: 0.30, speed: 0.6, blastR: 68,  types: ['normal','mega'],                   name: 'BLAZE',     tip: '3 clicks now ‚Äî plan your sequence.' },
    { particles: 45, clicks: 3, target3: 0.72, target2: 0.50, target1: 0.28, speed: 0.7, blastR: 66,  types: ['normal','fast','mega'],             name: 'INFERNO',   tip: 'Blue particles move fast ‚Äî intercept them.' },
    { particles: 50, clicks: 3, target3: 0.70, target2: 0.48, target1: 0.26, speed: 0.8, blastR: 64,  types: ['normal','fast','mega'],             name: 'NOVA',      tip: 'Chain bonus: longer chains = more points!' },
    { particles: 55, clicks: 3, target3: 0.68, target2: 0.46, target1: 0.25, speed: 0.9, blastR: 62,  types: ['normal','fast','shy','mega'],       name: 'SUPERNOVA', tip: 'Green SHY particles flee from explosions.' },
    { particles: 60, clicks: 4, target3: 0.72, target2: 0.50, target1: 0.28, speed: 1.0, blastR: 60,  types: ['normal','fast','shy','mega'],       name: 'QUASAR',    tip: '4 clicks ‚Äî corner the shy ones.' },
    { particles: 70, clicks: 4, target3: 0.70, target2: 0.48, target1: 0.26, speed: 1.1, blastR: 58,  types: ['normal','fast','shy','mega','ghost'], name: 'PULSAR',  tip: 'Purple GHOST particles phase in and out.' },
    { particles: 80, clicks: 5, target3: 0.75, target2: 0.55, target1: 0.30, speed: 1.2, blastR: 56,  types: ['normal','fast','shy','mega','ghost'], name: 'BIG BANG', tip: 'The final challenge. Detonate everything.' },
];

const PARTICLE_COLORS = {
    normal: '#ff8c00',
    fast:   '#00c8ff',
    mega:   '#ff4466',
    shy:    '#44ffaa',
    ghost:  '#c864ff',
};

const CHAIN_DELAY = 60;

// ======================== STATE ========================
let level = 0, score = 0, totalScore = 0;
let clicksLeft = 0, particles = [], explosions = [], floats = [], rings = [];
let chainCount = 0, maxChain = 0, detonated = 0;
let phase = 'menu'; // menu | playing | chaining | result
let levelStars = new Array(10).fill(0);
let totalStarsEarned = 0;
let achievements = {};
let shakeTime = 0;
let mouseX = -100, mouseY = -100;
let chainQueue = []; // queued explosions
let chainProcessing = false;

// Load save
try {
    const save = JSON.parse(localStorage.getItem('catalyst_save'));
    if (save) { levelStars = save.stars || levelStars; totalScore = save.totalScore || 0; achievements = save.achievements || {}; }
} catch(e) {}

function saveGame() {
    totalStarsEarned = levelStars.reduce((a,b) => a+b, 0);
    localStorage.setItem('catalyst_save', JSON.stringify({ stars: levelStars, totalScore, achievements }));
}

// ======================== ACHIEVEMENTS ========================
const ACHIEVE_DEFS = [
    { id: 'first_chain',   name: 'üîó First Chain',       check: () => maxChain >= 3 },
    { id: 'chain_5',       name: '‚õìÔ∏è Chain Master',      check: () => maxChain >= 5 },
    { id: 'chain_10',      name: 'üí• Chain God',          check: () => maxChain >= 10 },
    { id: 'chain_20',      name: '‚ò¢Ô∏è Nuclear',            check: () => maxChain >= 20 },
    { id: 'perfect',       name: '‚≠ê Perfect Level',      check: () => levelStars.some(s => s >= 3) },
    { id: 'all_15',        name: 'üåü Rising Star',        check: () => totalStarsEarned >= 15 },
    { id: 'all_25',        name: '‚ú® Constellation',      check: () => totalStarsEarned >= 25 },
    { id: 'score_5k',      name: 'üèÜ 5K Score',           check: () => score >= 5000 },
    { id: 'complete',      name: 'üéÜ Big Bang Master',    check: () => levelStars.every(s => s >= 1) },
    { id: 'all_perfect',   name: 'üëë Perfectionist',      check: () => levelStars.every(s => s >= 3) },
];

function checkAchievements() {
    ACHIEVE_DEFS.forEach(a => {
        if (!achievements[a.id] && a.check()) {
            achievements[a.id] = true;
            showAchievement(a.name);
            saveGame();
        }
    });
}

function showAchievement(text) {
    const el = document.createElement('div');
    el.className = 'achievement';
    el.textContent = `üèÖ ${text}`;
    achieveBox.appendChild(el);
    setTimeout(() => el.remove(), 4000);
}

// ======================== PARTICLES ========================
function spawnParticles() {
    particles = [];
    const cfg = LEVELS[level];
    const margin = 50;

    // Spawn in clusters (3-6 clusters) to make chains actually possible
    const clusterCount = 3 + Math.floor(level / 3);
    const clusters = [];
    for (let i = 0; i < clusterCount; i++) {
        clusters.push({
            x: margin + Math.random() * (W - margin * 2),
            y: margin + Math.random() * (H - margin * 2),
            spread: 60 + Math.random() * 50 // how tight the cluster is
        });
    }

    for (let i = 0; i < cfg.particles; i++) {
        const type = cfg.types[Math.floor(Math.random() * cfg.types.length)];
        const angle = Math.random() * Math.PI * 2;
        let speed = (0.3 + Math.random() * 0.5) * cfg.speed;
        let r = 7;

        if (type === 'fast') speed *= 1.6;
        if (type === 'mega') { r = 11; speed *= 0.5; }
        if (type === 'shy') speed *= 0.4;
        if (type === 'ghost') speed *= 0.8;

        // Pick a random cluster and spawn near it
        const cluster = clusters[Math.floor(Math.random() * clusters.length)];
        const cx = cluster.x + (Math.random() - 0.5) * cluster.spread * 2;
        const cy = cluster.y + (Math.random() - 0.5) * cluster.spread * 2;

        particles.push({
            x: Math.max(margin, Math.min(W - margin, cx)),
            y: Math.max(margin, Math.min(H - margin, cy)),
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            r, type, color: PARTICLE_COLORS[type],
            alive: true, exploding: false, explodeTimer: 0,
            blastR: type === 'mega' ? cfg.blastR * 1.5 : cfg.blastR,
            alpha: 1, ghostPhase: Math.random() * Math.PI * 2,
            points: type === 'mega' ? 150 : type === 'ghost' ? 120 : 100,
        });
    }
}

// ======================== CHAIN REACTION ENGINE ========================
function detonateAt(x, y, radius, isClick) {
    // Visual explosion ring
    rings.push({ x, y, r: 0, maxR: radius, life: 1, isClick });
    if (isClick) shakeTime = 6;

    // Find particles in range
    const hit = [];
    particles.forEach(p => {
        if (!p.alive || p.exploding) return;
        const dist = Math.hypot(p.x - x, p.y - y);
        if (dist < radius + p.r) {
            hit.push(p);
        }
    });

    // Queue them for sequential detonation (creates visible chain)
    hit.forEach((p, i) => {
        setTimeout(() => {
            if (!p.alive || p.exploding) return;
            p.exploding = true;
            p.explodeTimer = 0;
            detonated++;
            chainCount++;
            if (chainCount > maxChain) maxChain = chainCount;

            const mul = Math.min(chainCount, 20);
            const pts = p.points * mul;
            score += pts;

            shakeTime = Math.min(3 + Math.floor(chainCount / 3), 12);

            // Floating score
            floats.push({ x: p.x, y: p.y - 10, text: `+${pts}`, color: p.color, size: 10, life: 1, dy: -1 });
            if (chainCount >= 3 && chainCount % 2 === 1) {
                floats.push({ x: p.x, y: p.y - 28, text: `CHAIN x${chainCount}!`, color: '#ffd700', size: Math.min(10 + chainCount, 20), life: 1.2, dy: -0.8 });
            }

            // Burst particles visual
            for (let j = 0; j < 6; j++) {
                const a = (j / 6) * Math.PI * 2;
                floats.push({ x: p.x, y: p.y, dx: Math.cos(a)*3, dy: Math.sin(a)*3, text: '', color: p.color, size: 3, life: 0.7, isPart: true });
            }

            // Shy particles nearby flee
            particles.forEach(other => {
                if (!other.alive || other.exploding || other.type !== 'shy') return;
                const d = Math.hypot(other.x - p.x, other.y - p.y);
                if (d < p.blastR * 2) {
                    const flee = Math.atan2(other.y - p.y, other.x - p.x);
                    other.dx += Math.cos(flee) * 2;
                    other.dy += Math.sin(flee) * 2;
                }
            });

            // This particle will explode after a brief visual delay, triggering neighbors
            setTimeout(() => {
                if (p.alive) {
                    p.alive = false;
                    detonateAt(p.x, p.y, p.blastR, false);
                }
            }, 150);
        }, i * CHAIN_DELAY);
    });

    // Check if everything settled
    const totalDelay = (hit.length + 2) * CHAIN_DELAY + 400;
    setTimeout(() => checkDone(), totalDelay);
}

function checkDone() {
    // If any particle is still mid-explosion, wait more
    if (particles.some(p => p.exploding && p.alive)) {
        setTimeout(checkDone, 300);
        return;
    }
    // If we have clicks left, let player continue
    if (clicksLeft > 0) {
        phase = 'playing';
        return;
    }
    // All clicks used and chain done ‚Üí end level
    if (phase !== 'result') {
        setTimeout(endLevel, 600);
    }
}

// ======================== GAME FLOW ========================
function startGame() { showLevelSelect(); }

function showLevelSelect() {
    totalStarsEarned = levelStars.reduce((a,b) => a+b, 0);
    let html = `<h2>SELECT LEVEL</h2>`;
    html += `<div class="stat-row"><span class="stat-label">TOTAL STARS</span><span class="stat-value">${totalStarsEarned}/30 ${'‚≠ê'.repeat(Math.min(totalStarsEarned, 10))}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">SCORE</span><span class="stat-value">${totalScore.toLocaleString()}</span></div>`;
    html += `<div class="level-select">`;
    for (let i = 0; i < 10; i++) {
        const unlocked = i === 0 || levelStars[i - 1] >= 1;
        const stars = levelStars[i];
        const starsStr = '‚òÖ'.repeat(stars) + '‚òÜ'.repeat(3 - stars);
        html += `<div class="level-btn ${unlocked ? '' : 'locked'}" onclick="${unlocked ? `selectLevel(${i})` : ''}">
            ${i + 1}<br><span style="font-size:7px;color:rgba(255,255,255,0.4)">${LEVELS[i].name}</span>
            <span class="lvl-stars">${starsStr}</span>
        </div>`;
    }
    html += `</div>`;
    html += `<p class="tip">üéØ Click clusters of particles to trigger chain reactions</p>`;
    overlay.innerHTML = html;
    overlay.classList.remove('hidden');
    phase = 'menu';
}

function selectLevel(idx) {
    level = idx;
    score = 0; chainCount = 0; maxChain = 0; detonated = 0;
    clicksLeft = LEVELS[level].clicks;
    spawnParticles();
    overlay.classList.add('hidden');
    phase = 'playing';
    updateHUD();
}

function endLevel() {
    phase = 'result';
    const cfg = LEVELS[level];
    const total = cfg.particles;
    const pct = detonated / total;

    let stars = 0;
    if (pct >= cfg.target1) stars = 1;
    if (pct >= cfg.target2) stars = 2;
    if (pct >= cfg.target3) stars = 3;

    const starBonus = stars * 500;
    const chainBonus = maxChain * 100;
    score += starBonus + chainBonus;
    totalScore += score;

    if (stars > levelStars[level]) levelStars[level] = stars;
    saveGame();
    checkAchievements();

    const starsDisplay = [0,1,2].map(i => i < stars ? '‚≠ê' : '‚ö´').join(' ');
    const pctStr = Math.round(pct * 100);
    const pass = stars >= 1;

    let html = `<h2>${pass ? (stars === 3 ? '‚≠ê PERFECT! ‚≠ê' : 'LEVEL CLEAR!') : '‚ùå NOT ENOUGH'}</h2>`;
    html += `<div class="stars-display">${starsDisplay}</div>`;
    html += `<div class="stat-row"><span class="stat-label">DETONATED</span><span class="stat-value">${detonated}/${total} (${pctStr}%)</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">MAX CHAIN</span><span class="stat-value">x${maxChain}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">CHAIN BONUS</span><span class="stat-value">+${chainBonus}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">STAR BONUS</span><span class="stat-value">+${starBonus}</span></div>`;
    html += `<div class="stat-row"><span class="stat-label">LEVEL SCORE</span><span class="stat-value" style="color:#ff8c00;font-size:14px">${score.toLocaleString()}</span></div>`;

    // Star thresholds explanation
    html += `<div style="margin-top:8px">`;
    html += `<span class="stat-label">‚òÖ ${Math.round(cfg.target1*100)}%  ‚òÖ‚òÖ ${Math.round(cfg.target2*100)}%  ‚òÖ‚òÖ‚òÖ ${Math.round(cfg.target3*100)}%</span>`;
    html += `</div>`;

    html += `<div style="display:flex;gap:12px;margin-top:14px;flex-wrap:wrap;justify-content:center">`;
    if (pass && level < 9) {
        html += `<button class="btn" onclick="selectLevel(${level + 1})">NEXT ‚Üí</button>`;
    }
    html += `<button class="btn btn-secondary" onclick="selectLevel(${level})">RETRY</button>`;
    html += `<button class="btn btn-secondary" onclick="showLevelSelect()">LEVELS</button>`;
    html += `</div>`;

    if (pass && level >= 9) {
        html += `<p style="color:#ffd700;margin-top:12px;font-family:'Press Start 2P',cursive;font-size:10px">üéÜ ALL LEVELS COMPLETE!</p>`;
    }

    overlay.innerHTML = html;
    overlay.classList.remove('hidden');
}

// ======================== INPUT ========================
canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

canvas.addEventListener('click', e => {
    if (phase !== 'playing' || clicksLeft <= 0) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    clicksLeft--;
    chainCount = 0;
    phase = 'chaining';
    detonateAt(x, y, LEVELS[level].blastR * 0.9, true);
    updateHUD();
});

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (phase !== 'playing' || clicksLeft <= 0) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    const y = e.touches[0].clientY - rect.top;
    clicksLeft--;
    chainCount = 0;
    phase = 'chaining';
    detonateAt(x, y, LEVELS[level].blastR * 0.9, true);
    updateHUD();
}, { passive: false });

// ======================== HUD ========================
function updateHUD() {
    document.getElementById('hScore').textContent = score.toLocaleString();
    document.getElementById('hLevel').textContent = `LV ${level + 1}`;
    document.getElementById('hClicks').textContent = clicksLeft > 0 ? '‚óè '.repeat(clicksLeft).trim() : '‚Äî';
    const s = levelStars[level];
    document.getElementById('hStars').textContent = '‚òÖ'.repeat(s) + '‚òÜ'.repeat(3 - s);
}

// ======================== UPDATE ========================
function update() {
    if (phase === 'menu' || phase === 'result') return;

    particles.forEach(p => {
        if (!p.alive) return;

        if (!p.exploding) {
            p.x += p.dx;
            p.y += p.dy;

            // Bounce
            if (p.x - p.r < 0) { p.x = p.r; p.dx = Math.abs(p.dx); }
            if (p.x + p.r > W) { p.x = W - p.r; p.dx = -Math.abs(p.dx); }
            if (p.y - p.r < 0) { p.y = p.r; p.dy = Math.abs(p.dy); }
            if (p.y + p.r > H) { p.y = H - p.r; p.dy = -Math.abs(p.dy); }

            // Dampen shy flee speed over time
            if (p.type === 'shy') {
                const spd = Math.hypot(p.dx, p.dy);
                if (spd > LEVELS[level].speed * 0.5) {
                    p.dx *= 0.995;
                    p.dy *= 0.995;
                }
            }

            // Ghost phase
            if (p.type === 'ghost') {
                p.ghostPhase += 0.025;
                p.alpha = 0.25 + (Math.sin(p.ghostPhase) * 0.5 + 0.5) * 0.75;
            }
        } else {
            // Exploding visual
            p.explodeTimer++;
        }
    });

    // Explosion rings
    rings = rings.filter(r => {
        r.r += 5;
        r.life -= 0.035;
        return r.life > 0;
    });

    // Floats
    floats = floats.filter(f => {
        if (f.isPart) {
            f.x += (f.dx || 0);
            f.y += (f.dy || 0);
            f.dy = (f.dy || 0) + 0.08;
        } else {
            f.y += (f.dy || 0);
        }
        f.life -= 0.016;
        return f.life > 0;
    });

    if (shakeTime > 0) shakeTime--;
    updateHUD();
}

// ======================== DRAW ========================
function draw() {
    ctx.save();
    if (shakeTime > 0) {
        const s = shakeTime * 0.6;
        ctx.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
    }

    // BG
    ctx.fillStyle = LEVELS[level]?.bg || '#06060f';
    ctx.fillRect(0, 0, W, H);

    // Grid
    ctx.strokeStyle = 'rgba(255,140,0,0.015)';
    ctx.lineWidth = 1;
    for (let x = 0; x < W; x += 50) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y = 0; y < H; y += 50) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    // Blast radius preview on cursor
    if (phase === 'playing' && clicksLeft > 0) {
        const br = LEVELS[level].blastR * 0.9;
        ctx.strokeStyle = 'rgba(255,140,0,0.12)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, br, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);

        // Highlight particles in range
        particles.forEach(p => {
            if (!p.alive || p.exploding) return;
            const d = Math.hypot(p.x - mouseX, p.y - mouseY);
            if (d < br + p.r) {
                ctx.strokeStyle = `rgba(255,255,255,0.15)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r + 4, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    }

    // Explosion rings
    rings.forEach(r => {
        ctx.globalAlpha = r.life * 0.4;
        ctx.strokeStyle = r.isClick ? '#ffffff' : '#ff8c00';
        ctx.lineWidth = r.isClick ? 3 : 2;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
        ctx.stroke();

        // Inner fill
        const grad = ctx.createRadialGradient(r.x, r.y, 0, r.x, r.y, r.r);
        grad.addColorStop(0, `rgba(255,200,100,${r.life * 0.15})`);
        grad.addColorStop(1, 'rgba(255,140,0,0)');
        ctx.fillStyle = grad;
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Particles
    particles.forEach(p => {
        if (!p.alive && !p.exploding) return;
        ctx.globalAlpha = p.alpha || 1;

        if (p.exploding) {
            // Flash and shrink
            const t = Math.min(p.explodeTimer / 15, 1);
            ctx.globalAlpha = 1 - t;
            ctx.fillStyle = '#fff';
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r * (1 + t * 2), 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        } else {
            // Glow
            ctx.shadowColor = p.color;
            ctx.shadowBlur = p.type === 'mega' ? 20 : 12;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.arc(p.x - p.r*0.2, p.y - p.r*0.2, p.r*0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Type visual cues
            if (p.type === 'fast') {
                // Speed trail
                ctx.strokeStyle = `rgba(0,200,255,0.25)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p.x - p.dx*6, p.y - p.dy*6);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
            }
            if (p.type === 'mega') {
                // Blast radius hint
                ctx.strokeStyle = 'rgba(255,68,102,0.08)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.blastR * 0.4, 0, Math.PI * 2);
                ctx.stroke();
                // Size label
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '7px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText('M', p.x, p.y + 3);
            }
            if (p.type === 'shy') {
                ctx.strokeStyle = 'rgba(68,255,170,0.15)';
                ctx.setLineDash([2,3]);
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            if (p.type === 'ghost') {
                ctx.strokeStyle = `rgba(200,100,255,${p.alpha * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r + 3 + Math.sin(p.ghostPhase) * 2, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    });
    ctx.globalAlpha = 1;

    // Floats
    floats.forEach(f => {
        ctx.globalAlpha = Math.max(0, f.life);
        if (f.isPart) {
            ctx.fillStyle = f.color;
            ctx.fillRect(f.x - f.size/2, f.y - f.size/2, f.size, f.size);
        } else if (f.text) {
            ctx.fillStyle = f.color;
            ctx.font = `${f.size}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.shadowColor = f.color;
            ctx.shadowBlur = 8;
            ctx.fillText(f.text, f.x, f.y);
            ctx.shadowBlur = 0;
        }
    });
    ctx.globalAlpha = 1;

    // Progress bar
    if (phase === 'playing' || phase === 'chaining') {
        const total = LEVELS[level].particles;
        const pct = detonated / total;
        const cfg = LEVELS[level];
        const barY = H - 8;
        const barX = 20;
        const barW = W - 40;

        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        ctx.fillRect(barX, barY, barW, 5);

        const barColor = pct >= cfg.target3 ? '#ffd700' : pct >= cfg.target2 ? '#44ffaa' : pct >= cfg.target1 ? '#ff8c00' : '#ff4466';
        ctx.fillStyle = barColor;
        ctx.shadowColor = barColor;
        ctx.shadowBlur = 6;
        ctx.fillRect(barX, barY, barW * pct, 5);
        ctx.shadowBlur = 0;

        // Star markers
        [cfg.target1, cfg.target2, cfg.target3].forEach((t, i) => {
            const tx = barX + barW * t;
            ctx.fillStyle = pct >= t ? '#ffd700' : 'rgba(255,255,255,0.2)';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚òÖ', tx, barY - 3);
        });
    }

    // Bottom tip during play
    if (phase === 'playing' && clicksLeft > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.font = '9px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(LEVELS[level].tip, W/2, H - 18);
    }
    if (phase === 'chaining') {
        ctx.fillStyle = 'rgba(255,140,0,0.5)';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        const dots = '.'.repeat(1 + Math.floor(Date.now() / 300) % 3);
        ctx.fillText(`CHAIN REACTING${dots}`, W/2, H - 18);
    }

    ctx.restore();
}

// ======================== LOOP ========================
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
