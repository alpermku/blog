<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Neon Pong - Arcade</title>
<style>
:root{--bg:#05070d;--neon:#43f3ff;--hot:#ff4fd8;--ok:#8cff6b;--gold:#ffd700;--warn:#ff6347}
*{box-sizing:border-box;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
body{margin:0;min-height:100vh;min-height:100dvh;display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(ellipse at 30% 15%,#11162a 0%,var(--bg) 60%);color:#dbe7ff;font-family:Inter,system-ui,sans-serif;overflow:hidden}
.wrap{width:min(980px,98vw);position:relative}
.hud{display:flex;justify-content:space-between;align-items:center;gap:6px;padding:4px 0;flex-wrap:wrap;font-size:.85rem}
.badge{padding:4px 10px;border:1px solid #2b355f;border-radius:999px;background:#0b1022;white-space:nowrap}
.badge.combo{color:var(--gold);border-color:#665500;transition:transform .15s}
.badge.combo.pop{transform:scale(1.25)}
.btn{background:#0d1430;border:1px solid #324079;color:#dbe7ff;padding:6px 12px;border-radius:10px;cursor:pointer;font-size:.85rem}
.btn:active{background:#1a2550}
canvas{width:100%;display:block;border:1px solid #1e2a50;border-radius:12px;background:#060913;box-shadow:0 0 40px #0ef1 inset,0 0 18px #7b2cff22}
.touch-zone{display:none;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
.touch-btn{padding:18px 0;border-radius:12px;border:1px solid #2d3a6d;background:#0b1230;color:#dbe7ff;font-size:1.1rem;font-weight:600;user-select:none}
.touch-btn:active{background:#182255}
.info{font-size:.78rem;opacity:.7;margin-top:6px;text-align:center}

/* Overlay screens */
.overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(5,7,13,.88);border-radius:12px;z-index:10;gap:14px;padding:20px;text-align:center;backdrop-filter:blur(6px)}
.overlay h2{margin:0;font-size:1.6rem;letter-spacing:1px}
.overlay p{margin:0;opacity:.85;font-size:.95rem;max-width:340px;line-height:1.5}
.overlay .stars{font-size:2rem;letter-spacing:8px;margin:6px 0}
.overlay .btn-big{padding:12px 32px;font-size:1.05rem;border-radius:14px;border:1px solid var(--neon);color:var(--neon);background:#0a1535;cursor:pointer;transition:background .2s}
.overlay .btn-big:hover,.overlay .btn-big:active{background:#132050}
.level-list{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:8px}
.level-cell{padding:10px 6px;border-radius:10px;border:1px solid #2a3560;background:#0c1330;cursor:pointer;text-align:center;font-size:.85rem;transition:border-color .2s}
.level-cell.locked{opacity:.4;pointer-events:none}
.level-cell.current{border-color:var(--neon)}
.level-cell .cell-stars{font-size:.7rem;display:block;margin-top:2px}
.powerup-toast{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.4rem;font-weight:700;color:var(--gold);text-shadow:0 0 20px var(--gold);opacity:0;transition:opacity .3s,transform .3s;pointer-events:none;z-index:5}
.powerup-toast.show{opacity:1;transform:translate(-50%,-60%)}

@media(orientation:portrait){
  canvas{aspect-ratio:9/16}
  .touch-zone{display:grid}
}
@media(orientation:landscape){
  canvas{aspect-ratio:16/9}
}
@media(max-width:500px){
  .hud{font-size:.75rem}
  .badge{padding:3px 7px}
}
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="hud">
    <div class="badge" id="levelBadge">Level 1</div>
    <div class="badge" id="score">0</div>
    <div class="badge combo" id="combo"></div>
    <button class="btn" id="menuBtn">‚ò∞</button>
  </div>
  <canvas id="game"></canvas>
  <div class="touch-zone" id="touchZone">
    <button class="touch-btn" id="upBtn">‚ñ≤</button>
    <button class="touch-btn" id="downBtn">‚ñº</button>
  </div>
  <div class="info">Klavye: W/S ‚Üë/‚Üì ‚Ä¢ Mobil: buton veya sol yarƒ±yƒ± s√ºr√ºkle</div>
  <div class="powerup-toast" id="toast"></div>

  <!-- Menu Overlay -->
  <div class="overlay" id="menuOverlay" style="display:none">
    <h2>üèì NEON PONG</h2>
    <p>B√∂l√ºmler</p>
    <div class="level-list" id="levelList"></div>
    <button class="btn-big" id="resumeBtn">Devam Et</button>
  </div>

  <!-- Level Start Overlay -->
  <div class="overlay" id="startOverlay">
    <h2 id="startTitle">LEVEL 1</h2>
    <p id="startDesc">Klasik pong. CPU yava≈ü, top sakin.</p>
    <button class="btn-big" id="startBtn">BA≈ûLA</button>
  </div>

  <!-- Level Complete Overlay -->
  <div class="overlay" id="winOverlay" style="display:none">
    <h2>LEVEL TAMAMLANDI!</h2>
    <div class="stars" id="winStars">‚≠ê‚≠ê‚≠ê</div>
    <p id="winStats"></p>
    <button class="btn-big" id="nextBtn">SONRAKƒ∞ B√ñL√úM ‚Üí</button>
  </div>

  <!-- Game Over Overlay -->
  <div class="overlay" id="loseOverlay" style="display:none">
    <h2 style="color:var(--warn)">YENƒ∞LDƒ∞N</h2>
    <p id="loseStats"></p>
    <button class="btn-big" id="retryBtn">TEKRAR DENE</button>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// NEON PONG v2 ‚Äî Game Design Research Applied
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Flow Theory: Dynamic difficulty per level
// Variable Ratio Reinforcement: Random power-ups
// Juice: Particles, screen shake, hit flash, trails
// Dopamine Loops: Combo system, star ratings
// Loss Aversion: Streak loss feedback
// Progressive Mastery: 10 levels with unique mechanics
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const $ = id => document.getElementById(id);
const c = $('game'), ctx = c.getContext('2d');

// ‚îÄ‚îÄ LEVEL DEFINITIONS ‚îÄ‚îÄ
// Each level adds a new mechanic (progressive disclosure)
const LEVELS = [
  { name:'Uyanƒ±≈ü',       desc:'Klasik pong. CPU yava≈ü, top sakin.',                  cpuSpeed:3.8, ballSpeed:4.2, winScore:5,  shrinkCPU:false, powerups:false, multiBall:false, walls:false, accel:1.02 },
  { name:'Isƒ±nma',        desc:'Top biraz hƒ±zlandƒ±. Reflekslerin hazƒ±r mƒ±?',          cpuSpeed:4.2, ballSpeed:5.0, winScore:5,  shrinkCPU:false, powerups:false, multiBall:false, walls:false, accel:1.025 },
  { name:'ƒ∞lk G√º√ß',      desc:'Power-up\'lar sahneye giriyor!',                      cpuSpeed:4.5, ballSpeed:5.2, winScore:5,  shrinkCPU:false, powerups:true,  multiBall:false, walls:false, accel:1.025 },
  { name:'Baskƒ±',         desc:'CPU daha akƒ±llƒ±. Kombolarƒ± ka√ßƒ±rma.',                 cpuSpeed:5.2, ballSpeed:5.5, winScore:6,  shrinkCPU:false, powerups:true,  multiBall:false, walls:false, accel:1.03 },
  { name:'Daralan Alan',  desc:'CPU raketi k√º√ß√ºl√ºyor ama daha hƒ±zlƒ±.',                cpuSpeed:5.8, ballSpeed:5.8, winScore:6,  shrinkCPU:true,  powerups:true,  multiBall:false, walls:false, accel:1.03 },
  { name:'Kaos',          desc:'√áoklu top! Hepsini takip edebilecek misin?',          cpuSpeed:5.0, ballSpeed:5.5, winScore:6,  shrinkCPU:false, powerups:true,  multiBall:true,  walls:false, accel:1.025 },
  { name:'Labirent',      desc:'Sahada engeller var. Toplar sekmeli.',                cpuSpeed:5.5, ballSpeed:5.8, winScore:7,  shrinkCPU:false, powerups:true,  multiBall:false, walls:true,  accel:1.03 },
  { name:'Fƒ±rtƒ±na',       desc:'Her ≈üey bir arada. G√º√ß, hƒ±z, engel.',                cpuSpeed:6.0, ballSpeed:6.2, winScore:7,  shrinkCPU:true,  powerups:true,  multiBall:true,  walls:true,  accel:1.035 },
  { name:'Son Sƒ±nav',     desc:'CPU neredeyse m√ºkemmel. Tek ≈üansƒ±n kombo.',           cpuSpeed:7.0, ballSpeed:6.5, winScore:8,  shrinkCPU:true,  powerups:true,  multiBall:false, walls:true,  accel:1.04 },
  { name:'Efsane',        desc:'Buraya kadar gelen √ßok az. Kanƒ±tla.',                 cpuSpeed:7.8, ballSpeed:7.0, winScore:10, shrinkCPU:true,  powerups:true,  multiBall:true,  walls:true,  accel:1.04 },
];

// ‚îÄ‚îÄ SAVE STATE ‚îÄ‚îÄ
const SAVE_KEY = 'neonpong_save';
let save = JSON.parse(localStorage.getItem(SAVE_KEY) || 'null') || { unlocked:1, stars:[], highScores:[] };
function persist() { localStorage.setItem(SAVE_KEY, JSON.stringify(save)); }

// ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ
let W, H, portrait;
let currentLevel = 0;
let playing = false;
let paused = false;

const keys = new Set();
const touch = { up:false, down:false, dragY:null };

// Player & CPU paddles
let p1, p2;
// Balls array (multi-ball support)
let balls = [];
// Power-ups
let powerups = [];
// Walls/obstacles
let walls = [];
// Particles
let particles = [];
// Screen shake
let shake = { x:0, y:0, intensity:0 };
// Combo
let combo = 0;
let maxCombo = 0;
let comboTimer = 0;
// Scores
let scoreP1 = 0, scoreP2 = 0;
// Active effects
let effects = { bigPaddle:0, slowMo:0, magnet:0 };
// Level config ref
let lv;
// Dynamic difficulty offset (Flow theory: adjust if player struggles)
let ddaOffset = 0;
// Rally counter (hits without scoring)
let rally = 0;

// Level theme colors
const THEMES = [
  { paddle:'#43f3ff', cpu:'#ff4fd8', ball:'#8cff6b', accent:'#43f3ff' },
  { paddle:'#00e5ff', cpu:'#ff6090', ball:'#b2ff59', accent:'#00e5ff' },
  { paddle:'#64ffda', cpu:'#ff4081', ball:'#ffff00', accent:'#64ffda' },
  { paddle:'#18ffff', cpu:'#f50057', ball:'#76ff03', accent:'#18ffff' },
  { paddle:'#00bcd4', cpu:'#e91e63', ball:'#cddc39', accent:'#00bcd4' },
  { paddle:'#26c6da', cpu:'#ec407a', ball:'#ffd740', accent:'#26c6da' },
  { paddle:'#4dd0e1', cpu:'#f06292', ball:'#ff6e40', accent:'#4dd0e1' },
  { paddle:'#80deea', cpu:'#ff80ab', ball:'#ffd180', accent:'#80deea' },
  { paddle:'#b2ebf2', cpu:'#ff80ab', ball:'#ff9100', accent:'#b2ebf2' },
  { paddle:'#ffd700', cpu:'#ff1744', ball:'#ffffff', accent:'#ffd700' },
];

// ‚îÄ‚îÄ POWER-UP TYPES ‚îÄ‚îÄ
const PU_TYPES = [
  { id:'big',    icon:'üî≤', label:'B√úY√úK RAKET',    color:'#43f3ff', dur:8000 },
  { id:'slow',   icon:'üïê', label:'YAVA≈û MOD',      color:'#b388ff', dur:5000 },
  { id:'magnet', icon:'üß≤', label:'MIKNATIK',        color:'#ff9100', dur:6000 },
  { id:'shrink', icon:'üìè', label:'CPU K√ú√á√úLT',      color:'#ff4081', dur:7000 },
  { id:'multi',  icon:'‚ö°', label:'√áƒ∞FT TOP',       color:'#ffff00', dur:0    },
];

// ‚îÄ‚îÄ RESIZE & LAYOUT ‚îÄ‚îÄ
function resize() {
  portrait = matchMedia('(orientation:portrait)').matches;
  W = portrait ? 540 : 960;
  H = portrait ? 960 : 540;
  c.width = W; c.height = H;
}
addEventListener('resize', () => { resize(); initPaddles(); });

// ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ
addEventListener('keydown', e => { keys.add(e.key.toLowerCase()); e.preventDefault(); });
addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

function bindHold(btn, key) {
  const on = () => touch[key] = true, off = () => touch[key] = false;
  btn.addEventListener('touchstart', e => { e.preventDefault(); on(); }, { passive:false });
  btn.addEventListener('touchend', off); btn.addEventListener('touchcancel', off);
  btn.addEventListener('mousedown', on); btn.addEventListener('mouseup', off); btn.addEventListener('mouseleave', off);
}
bindHold($('upBtn'), 'up');
bindHold($('downBtn'), 'down');

c.addEventListener('touchstart', onTouch, { passive:false });
c.addEventListener('touchmove', onTouch, { passive:false });
c.addEventListener('touchend', () => touch.dragY = null);
function onTouch(e) {
  const t = e.touches[0]; if (!t) return;
  const r = c.getBoundingClientRect();
  const tx = (t.clientX - r.left) / r.width * W;
  const ty = (t.clientY - r.top) / r.height * H;
  if (tx < W * 0.5) { touch.dragY = ty; e.preventDefault(); }
}

// ‚îÄ‚îÄ INIT HELPERS ‚îÄ‚îÄ
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }

function initPaddles() {
  const pw = Math.round(W * 0.016);
  const ph = Math.round(H * 0.17);
  const margin = Math.round(W * 0.035);
  p1 = { x:margin, y:(H - ph) / 2, w:pw, h:ph, baseH:ph, speed: portrait ? 11 : 8 };
  p2 = { x:W - margin - pw, y:(H - ph) / 2, w:pw, h:ph, baseH:ph, speed: lv ? (lv.cpuSpeed + ddaOffset) : 4 };
  if (lv && lv.shrinkCPU) p2.h = Math.round(ph * 0.7);
}

function makeBall(fromCenter) {
  const speed = lv ? lv.ballSpeed : 5;
  const dir = Math.random() < 0.5 ? -1 : 1;
  const angle = rand(-0.6, 0.6);
  return {
    x: fromCenter ? W / 2 : rand(W * 0.3, W * 0.7),
    y: fromCenter ? H / 2 : rand(H * 0.2, H * 0.8),
    vx: Math.cos(angle) * speed * dir,
    vy: Math.sin(angle) * speed,
    r: Math.round(W * 0.01 + 3),
    trail: [],
    alive: true,
    lastHit: 0 // prevent double-hit
  };
}

function initWalls() {
  walls = [];
  if (!lv || !lv.walls) return;
  const count = currentLevel >= 9 ? 4 : currentLevel >= 7 ? 3 : 2;
  for (let i = 0; i < count; i++) {
    const vertical = Math.random() < 0.5;
    walls.push({
      x: rand(W * 0.25, W * 0.75),
      y: rand(H * 0.15, H * 0.85),
      w: vertical ? 8 : rand(60, 120),
      h: vertical ? rand(60, 120) : 8,
      glow: THEMES[currentLevel].accent
    });
  }
}

// ‚îÄ‚îÄ POWER-UP SPAWNING (Variable Ratio Schedule) ‚îÄ‚îÄ
let puTimer = 0;
function spawnPowerup() {
  if (!lv || !lv.powerups) return;
  if (powerups.length >= 2) return;
  const type = PU_TYPES[randInt(0, PU_TYPES.length - 1)];
  if (type.id === 'multi' && balls.length >= 3) return;
  powerups.push({
    ...type,
    x: rand(W * 0.3, W * 0.7),
    y: rand(H * 0.15, H * 0.85),
    size: 18,
    pulse: 0,
    age: 0
  });
}

// ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ
function emit(x, y, color, count, spread) {
  for (let i = 0; i < count; i++) {
    const angle = rand(0, Math.PI * 2);
    const speed = rand(1, spread);
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: rand(0.015, 0.04),
      r: rand(2, 5),
      color
    });
  }
}

function emitTrail(x, y, color) {
  particles.push({
    x, y,
    vx: rand(-0.3, 0.3), vy: rand(-0.3, 0.3),
    life: 0.6, decay: 0.03, r: rand(1.5, 3), color
  });
}

// ‚îÄ‚îÄ SCREEN SHAKE ‚îÄ‚îÄ
function doShake(intensity) {
  shake.intensity = Math.max(shake.intensity, intensity);
}

// ‚îÄ‚îÄ COMBO SYSTEM ‚îÄ‚îÄ
function addCombo() {
  combo++;
  if (combo > maxCombo) maxCombo = combo;
  comboTimer = 3000; // 3 sec to maintain
  const el = $('combo');
  el.textContent = combo >= 2 ? `üî• x${combo}` : '';
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  if (combo === 5) showToast('üî• ON FIRE!');
  if (combo === 10) showToast('üíé UNSTOPPABLE!');
}

function breakCombo() {
  if (combo >= 3) {
    // Loss aversion feedback ‚Äî visual pain
    doShake(6);
    emit(p1.x + p1.w, p1.y + p1.h / 2, '#ff4444', 20, 5);
    showToast('üíî Kombo kƒ±rƒ±ldƒ±!');
  }
  combo = 0;
  $('combo').textContent = '';
}

// ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ
function showToast(text) {
  const el = $('toast');
  el.textContent = text;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 1200);
}

// ‚îÄ‚îÄ COLLISION ‚îÄ‚îÄ
function collideWall(ball) {
  for (const w of walls) {
    if (ball.x + ball.r > w.x && ball.x - ball.r < w.x + w.w &&
        ball.y + ball.r > w.y && ball.y - ball.r < w.y + w.h) {
      // Determine penetration direction
      const overlapL = (ball.x + ball.r) - w.x;
      const overlapR = (w.x + w.w) - (ball.x - ball.r);
      const overlapT = (ball.y + ball.r) - w.y;
      const overlapB = (w.y + w.h) - (ball.y - ball.r);
      const minX = Math.min(overlapL, overlapR);
      const minY = Math.min(overlapT, overlapB);
      if (minX < minY) ball.vx *= -1;
      else ball.vy *= -1;
      emit(ball.x, ball.y, w.glow, 8, 3);
      doShake(2);
    }
  }
}

function collidePaddle(ball, paddle, dir) {
  const now = Date.now();
  if (now - ball.lastHit < 80) return false;
  if (ball.x + ball.r > paddle.x && ball.x - ball.r < paddle.x + paddle.w &&
      ball.y + ball.r > paddle.y && ball.y - ball.r < paddle.y + paddle.h) {
    ball.lastHit = now;
    ball.vx = Math.abs(ball.vx) * dir;
    const rel = (ball.y - (paddle.y + paddle.h / 2)) / (paddle.h / 2);
    ball.vy += rel * 1.8;
    // Accelerate
    const accel = lv ? lv.accel : 1.03;
    ball.vx *= accel;
    // Clamp max speed
    const maxSpd = 14;
    ball.vx = clamp(ball.vx, -maxSpd, maxSpd);
    ball.vy = clamp(ball.vy, -maxSpd * 0.7, maxSpd * 0.7);

    rally++;
    // Juice!
    const theme = THEMES[currentLevel];
    const hitColor = dir === 1 ? theme.paddle : theme.cpu;
    emit(ball.x, ball.y, hitColor, 12, 4);
    doShake(3);

    if (dir === 1) {
      addCombo();
      // Check power-up collection on rally milestones (variable ratio)
      if (rally % randInt(4, 8) === 0) spawnPowerup();
    }
    return true;
  }
  return false;
}

function collidePowerup(ball) {
  for (let i = powerups.length - 1; i >= 0; i--) {
    const pu = powerups[i];
    const dist = Math.hypot(ball.x - pu.x, ball.y - pu.y);
    if (dist < ball.r + pu.size) {
      // Activate!
      activatePowerup(pu);
      emit(pu.x, pu.y, pu.color, 25, 6);
      doShake(4);
      showToast(`${pu.icon} ${pu.label}`);
      powerups.splice(i, 1);
    }
  }
}

function activatePowerup(pu) {
  switch (pu.id) {
    case 'big':
      effects.bigPaddle = Date.now() + pu.dur;
      p1.h = Math.round(p1.baseH * 1.5);
      break;
    case 'slow':
      effects.slowMo = Date.now() + pu.dur;
      break;
    case 'shrink':
      p2.h = Math.round(p2.baseH * 0.5);
      setTimeout(() => { p2.h = lv && lv.shrinkCPU ? Math.round(p2.baseH * 0.7) : p2.baseH; }, pu.dur);
      break;
    case 'magnet':
      effects.magnet = Date.now() + pu.dur;
      break;
    case 'multi':
      if (balls.length < 3) balls.push(makeBall(true));
      break;
  }
}

// ‚îÄ‚îÄ CPU AI ‚îÄ‚îÄ
function updateCPU(dt) {
  // Target: predict ball arrival
  let target = H / 2;
  let closestBall = null;
  let closestDist = Infinity;
  for (const b of balls) {
    if (!b.alive) continue;
    if (b.vx > 0) { // heading toward CPU
      const dist = p2.x - b.x;
      if (dist < closestDist) { closestDist = dist; closestBall = b; }
    }
  }
  if (closestBall) {
    // Predict Y at paddle x
    const timeToArrive = (p2.x - closestBall.x) / closestBall.vx;
    target = closestBall.y + closestBall.vy * timeToArrive;
    // Add imperfection based on level (human-like errors)
    const errorRange = Math.max(0, 30 - currentLevel * 2.5);
    target += rand(-errorRange, errorRange);
  }
  const center = p2.y + p2.h / 2;
  const diff = target - center;
  const cpuSpd = (lv ? lv.cpuSpeed : 4) + ddaOffset;
  const move = clamp(diff, -cpuSpd, cpuSpd);
  p2.y = clamp(p2.y + move, 0, H - p2.h);
}

// ‚îÄ‚îÄ SCORING ‚îÄ‚îÄ
function playerScored() {
  scoreP1++;
  rally = 0;
  updateHUD();
  emit(W - 40, H / 2, '#8cff6b', 30, 8);
  doShake(5);
  // DDA: player doing well, tighten up (Flow theory)
  if (scoreP1 - scoreP2 >= 3) ddaOffset = clamp(ddaOffset + 0.3, -2, 2);
  checkWin();
}

function cpuScored() {
  scoreP2++;
  rally = 0;
  breakCombo();
  updateHUD();
  emit(40, H / 2, '#ff4444', 30, 8);
  doShake(6);
  // DDA: player struggling, ease up
  if (scoreP2 - scoreP1 >= 2) ddaOffset = clamp(ddaOffset - 0.4, -2, 2);
  checkWin();
}

function checkWin() {
  const target = lv ? lv.winScore : 5;
  if (scoreP1 >= target) {
    // Player wins!
    playing = false;
    const stars = calcStars();
    save.stars[currentLevel] = Math.max(save.stars[currentLevel] || 0, stars);
    if (currentLevel + 1 >= save.unlocked) {
      save.unlocked = Math.min(currentLevel + 2, LEVELS.length);
    }
    persist();
    showWin(stars);
  } else if (scoreP2 >= target) {
    playing = false;
    showLose();
  } else {
    respawnBall();
  }
}

function calcStars() {
  const diff = scoreP1 - scoreP2;
  if (diff >= 4 && maxCombo >= 5) return 3;
  if (diff >= 2) return 2;
  return 1;
}

function respawnBall() {
  balls = [makeBall(true)];
  if (lv && lv.multiBall && Math.random() < 0.3) {
    setTimeout(() => { if (playing) balls.push(makeBall(true)); }, 2000);
  }
}

// ‚îÄ‚îÄ UPDATE HUD ‚îÄ‚îÄ
function updateHUD() {
  $('score').textContent = `${scoreP1} : ${scoreP2}`;
  $('levelBadge').textContent = `Lv.${currentLevel + 1} ${lv ? lv.name : ''}`;
}

// ‚îÄ‚îÄ OVERLAYS ‚îÄ‚îÄ
function hideAllOverlays() {
  ['menuOverlay','startOverlay','winOverlay','loseOverlay'].forEach(id => $(id).style.display = 'none');
}

function showStart() {
  hideAllOverlays();
  $('startOverlay').style.display = 'flex';
  $('startTitle').textContent = `LEVEL ${currentLevel + 1}: ${LEVELS[currentLevel].name}`;
  $('startDesc').textContent = LEVELS[currentLevel].desc;
}

function showWin(stars) {
  hideAllOverlays();
  $('winOverlay').style.display = 'flex';
  $('winStars').textContent = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(3 - stars);
  $('winStats').textContent = `Skor: ${scoreP1}-${scoreP2} ‚Ä¢ Max Kombo: x${maxCombo}`;
  // Celebration particles
  for (let i = 0; i < 60; i++) emit(rand(0, W), rand(0, H), THEMES[currentLevel].accent, 1, 3);
}

function showLose() {
  hideAllOverlays();
  $('loseOverlay').style.display = 'flex';
  $('loseStats').textContent = `Skor: ${scoreP1}-${scoreP2} ‚Ä¢ Max Kombo: x${maxCombo}`;
}

function showMenu() {
  paused = true;
  hideAllOverlays();
  $('menuOverlay').style.display = 'flex';
  const list = $('levelList');
  list.innerHTML = '';
  for (let i = 0; i < LEVELS.length; i++) {
    const cell = document.createElement('div');
    cell.className = 'level-cell' + (i >= save.unlocked ? ' locked' : '') + (i === currentLevel ? ' current' : '');
    const starText = save.stars[i] ? '‚≠ê'.repeat(save.stars[i]) : (i < save.unlocked ? '‚Äî' : 'üîí');
    cell.innerHTML = `<strong>${i + 1}</strong><span class="cell-stars">${starText}</span>`;
    if (i < save.unlocked) cell.onclick = () => { currentLevel = i; startLevel(); };
    list.appendChild(cell);
  }
}

// ‚îÄ‚îÄ START LEVEL ‚îÄ‚îÄ
function startLevel() {
  hideAllOverlays();
  lv = LEVELS[currentLevel];
  scoreP1 = 0; scoreP2 = 0;
  combo = 0; maxCombo = 0; comboTimer = 0;
  ddaOffset = 0; rally = 0;
  effects = { bigPaddle:0, slowMo:0, magnet:0 };
  powerups = [];
  particles = [];
  puTimer = 0;
  $('combo').textContent = '';

  resize();
  initPaddles();
  initWalls();
  respawnBall();
  updateHUD();
  showStart();
}

// ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ
let lastTime = 0;
function loop(ts) {
  const rawDt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  const slowFactor = (effects.slowMo > Date.now()) ? 0.5 : 1;
  const dt = rawDt * slowFactor;

  if (playing && !paused) {
    // Player input
    let pv = 0;
    if (keys.has('w') || keys.has('arrowup') || touch.up) pv = -p1.speed;
    if (keys.has('s') || keys.has('arrowdown') || touch.down) pv = p1.speed;
    if (touch.dragY !== null) {
      p1.y = clamp(touch.dragY - p1.h / 2, 0, H - p1.h);
    } else {
      p1.y = clamp(p1.y + pv, 0, H - p1.h);
    }

    // Magnet effect: ball curves toward paddle
    if (effects.magnet > Date.now()) {
      for (const b of balls) {
        if (b.vx < 0) { // heading toward player
          const dy = (p1.y + p1.h / 2) - b.y;
          b.vy += Math.sign(dy) * 0.15;
        }
      }
    }

    // Big paddle effect
    if (effects.bigPaddle > 0 && effects.bigPaddle < Date.now()) {
      p1.h = p1.baseH;
      effects.bigPaddle = 0;
    }

    // CPU
    updateCPU(dt);

    // Balls
    for (const b of balls) {
      if (!b.alive) continue;
      b.x += b.vx; b.y += b.vy;
      b.trail.push({ x:b.x, y:b.y });
      if (b.trail.length > 14) b.trail.shift();

      // Wall bounce
      if (b.y - b.r < 0) { b.y = b.r; b.vy = Math.abs(b.vy); emit(b.x, 0, '#334', 5, 2); }
      if (b.y + b.r > H) { b.y = H - b.r; b.vy = -Math.abs(b.vy); emit(b.x, H, '#334', 5, 2); }

      // Obstacle walls
      collideWall(b);

      // Paddle collisions
      collidePaddle(b, p1, 1);
      collidePaddle(b, p2, -1);

      // Power-up collection
      collidePowerup(b);

      // Scoring
      if (b.x < -30) { b.alive = false; cpuScored(); }
      if (b.x > W + 30) { b.alive = false; playerScored(); }
    }

    balls = balls.filter(b => b.alive);
    if (balls.length === 0 && playing) respawnBall();

    // Combo decay
    if (combo > 0) {
      comboTimer -= rawDt * 1000;
      if (comboTimer <= 0) breakCombo();
    }

    // Power-up spawn timer (variable interval)
    if (lv && lv.powerups) {
      puTimer += rawDt * 1000;
      if (puTimer > rand(6000, 14000)) { puTimer = 0; spawnPowerup(); }
    }

    // Power-up age
    for (let i = powerups.length - 1; i >= 0; i--) {
      powerups[i].age += rawDt * 1000;
      powerups[i].pulse += rawDt * 3;
      if (powerups[i].age > 12000) { // disappear after 12s
        emit(powerups[i].x, powerups[i].y, powerups[i].color, 10, 3);
        powerups.splice(i, 1);
      }
    }
  }

  // Particles (always update for celebration effects)
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.life -= p.decay;
    p.vy += 0.02; // tiny gravity
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake decay
  if (shake.intensity > 0) {
    shake.x = rand(-shake.intensity, shake.intensity);
    shake.y = rand(-shake.intensity, shake.intensity);
    shake.intensity *= 0.88;
    if (shake.intensity < 0.3) shake.intensity = 0;
  }

  draw();
  requestAnimationFrame(loop);
}

// ‚îÄ‚îÄ DRAW ‚îÄ‚îÄ
function draw() {
  const theme = THEMES[currentLevel] || THEMES[0];
  ctx.save();
  ctx.translate(shake.x, shake.y);

  // Background
  ctx.fillStyle = '#060913';
  ctx.fillRect(-10, -10, W + 20, H + 20);

  // Center line
  ctx.strokeStyle = '#151e3a';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 14]);
  ctx.beginPath(); ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H); ctx.stroke();
  ctx.setLineDash([]);

  // Walls
  for (const w of walls) {
    ctx.shadowBlur = 10; ctx.shadowColor = w.glow;
    ctx.fillStyle = w.glow + '66';
    ctx.strokeStyle = w.glow;
    ctx.lineWidth = 1.5;
    ctx.fillRect(w.x, w.y, w.w, w.h);
    ctx.strokeRect(w.x, w.y, w.w, w.h);
    ctx.shadowBlur = 0;
  }

  // Ball trails
  for (const b of balls) {
    for (let i = 0; i < b.trail.length; i++) {
      const t = b.trail[i], a = (i + 1) / b.trail.length;
      ctx.fillStyle = hexAlpha(theme.ball, a * 0.3);
      ctx.beginPath(); ctx.arc(t.x, t.y, b.r * (0.3 + a * 0.7), 0, Math.PI * 2); ctx.fill();
    }
  }

  // Balls
  for (const b of balls) {
    ctx.shadowBlur = 20; ctx.shadowColor = theme.ball;
    ctx.fillStyle = theme.ball;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Paddles
  drawPaddle(p1, theme.paddle);
  drawPaddle(p2, theme.cpu);

  // Power-ups
  for (const pu of powerups) {
    const pulse = 1 + Math.sin(pu.pulse) * 0.15;
    const sz = pu.size * pulse;
    ctx.shadowBlur = 14; ctx.shadowColor = pu.color;
    ctx.fillStyle = pu.color + '33';
    ctx.beginPath(); ctx.arc(pu.x, pu.y, sz + 4, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.font = `${Math.round(sz)}px sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(pu.icon, pu.x, pu.y);
    // Blink if about to expire
    if (pu.age > 9000 && Math.sin(pu.age / 100) > 0) {
      ctx.fillStyle = pu.color + '22';
      ctx.beginPath(); ctx.arc(pu.x, pu.y, sz + 10, 0, Math.PI * 2); ctx.fill();
    }
  }

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Combo bar
  if (combo >= 2 && playing) {
    const barW = Math.min(combo / 10, 1) * (W * 0.3);
    const barH = 4;
    const barX = W / 2 - W * 0.15;
    const barY = 8;
    ctx.fillStyle = '#1a1a30';
    ctx.fillRect(barX, barY, W * 0.3, barH);
    const grad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
    grad.addColorStop(0, '#ffd700');
    grad.addColorStop(1, combo >= 8 ? '#ff4444' : '#ff9100');
    ctx.fillStyle = grad;
    ctx.fillRect(barX, barY, barW, barH);
  }

  // Active effects indicators
  let ey = 24;
  if (effects.bigPaddle > Date.now()) { drawEffectBadge('üî≤', ey, theme.paddle); ey += 18; }
  if (effects.slowMo > Date.now()) { drawEffectBadge('üïê', ey, '#b388ff'); ey += 18; }
  if (effects.magnet > Date.now()) { drawEffectBadge('üß≤', ey, '#ff9100'); ey += 18; }

  // Slow-mo vignette
  if (effects.slowMo > Date.now()) {
    const vg = ctx.createRadialGradient(W / 2, H / 2, W * 0.3, W / 2, H / 2, W * 0.7);
    vg.addColorStop(0, 'transparent');
    vg.addColorStop(1, 'rgba(100,50,200,0.12)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
  }

  ctx.restore();
}

function drawPaddle(p, color) {
  ctx.shadowBlur = 18; ctx.shadowColor = color;
  ctx.fillStyle = color;
  // Rounded rect
  const r = 4;
  ctx.beginPath();
  ctx.moveTo(p.x + r, p.y);
  ctx.lineTo(p.x + p.w - r, p.y);
  ctx.quadraticCurveTo(p.x + p.w, p.y, p.x + p.w, p.y + r);
  ctx.lineTo(p.x + p.w, p.y + p.h - r);
  ctx.quadraticCurveTo(p.x + p.w, p.y + p.h, p.x + p.w - r, p.y + p.h);
  ctx.lineTo(p.x + r, p.y + p.h);
  ctx.quadraticCurveTo(p.x, p.y + p.h, p.x, p.y + p.h - r);
  ctx.lineTo(p.x, p.y + r);
  ctx.quadraticCurveTo(p.x, p.y, p.x + r, p.y);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawEffectBadge(icon, y, color) {
  ctx.font = '13px sans-serif';
  ctx.fillStyle = color;
  ctx.textAlign = 'left';
  ctx.fillText(icon, 8, y);
}

function hexAlpha(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

// ‚îÄ‚îÄ EVENT HANDLERS ‚îÄ‚îÄ
$('startBtn').onclick = () => {
  hideAllOverlays();
  playing = true;
  paused = false;
};
$('nextBtn').onclick = () => {
  if (currentLevel < LEVELS.length - 1) {
    currentLevel++;
    startLevel();
  } else {
    showToast('üèÜ T√úM B√ñL√úMLER TAMAM!');
    showMenu();
  }
};
$('retryBtn').onclick = () => startLevel();
$('menuBtn').onclick = () => {
  if (paused) {
    hideAllOverlays();
    paused = false;
  } else {
    showMenu();
  }
};
$('resumeBtn').onclick = () => {
  hideAllOverlays();
  paused = false;
};

// ‚îÄ‚îÄ BOOT ‚îÄ‚îÄ
resize();
startLevel();
requestAnimationFrame(loop);
</script>
</body>
</html>
