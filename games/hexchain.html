<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hexchain - Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            background: #050510;
            overflow: hidden;
            font-family: 'JetBrains Mono', monospace;
            color: #fff;
            user-select: none;
            width: 100%; height: 100%;
            touch-action: none;
        }

        #app {
            display: flex;
            flex-direction: column;
            width: 100%; height: 100%;
        }

        /* === HUD TOP === */
        .hud {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .hud-box {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,136,170,0.25);
            border-radius: 8px;
            padding: 8px 14px;
            text-align: center;
            min-width: 80px;
        }

        .hud-box .label {
            font-size: 9px;
            color: rgba(255,136,170,0.5);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .hud-box .value {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #f8a;
            text-shadow: 0 0 8px rgba(255,136,170,0.4);
        }

        .hud-box.target .value { color: #ffd93d; text-shadow: 0 0 8px rgba(255,217,61,0.4); }
        .hud-box.moves .value { color: #6bcb77; text-shadow: 0 0 8px rgba(107,203,119,0.4); }
        .hud-box.moves.danger .value { color: #e74c3c; text-shadow: 0 0 8px rgba(231,76,60,0.5); }

        /* === PROGRESS BAR === */
        .progress-wrap {
            padding: 0 20px 8px;
            flex-shrink: 0;
        }
        .progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6ac1, #ffd93d);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* === CANVAS === */
        .canvas-wrap {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* === CHAIN POPUP === */
        .chain-popup {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: #ffd93d;
            text-shadow: 0 0 30px rgba(255,217,61,0.8);
            pointer-events: none;
            z-index: 30;
            opacity: 0;
            transition: all 0.4s ease-out;
        }
        .chain-popup.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        .chain-popup.fade {
            transform: translate(-50%, -80%) scale(0.8);
            opacity: 0;
        }

        /* === OVERLAYS === */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(5,5,16,0.94);
            z-index: 20;
            padding: 20px;
        }

        .overlay h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px; color: #f8a;
            text-shadow: 0 0 20px rgba(255,136,170,0.6);
            margin-bottom: 24px;
            text-align: center;
        }

        .overlay .rules {
            max-width: 360px;
            text-align: left;
            line-height: 2;
            font-size: 13px;
            color: rgba(255,220,230,0.8);
        }

        .overlay .rules b { color: #f8a; }
        .overlay .rules .icon { font-size: 16px; margin-right: 6px; }

        .overlay .stats {
            margin: 16px 0;
            text-align: center;
        }
        .overlay .stats .big {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #ffd93d;
            text-shadow: 0 0 12px rgba(255,217,61,0.5);
        }
        .overlay .stats .sub {
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            margin-top: 6px;
        }

        .btn {
            margin-top: 28px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: #050510;
            background: #f8a;
            border: none;
            border-radius: 6px;
            padding: 14px 28px;
            cursor: pointer;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        .btn:hover { background: #ffb3d0; transform: scale(1.05); }
        .btn:active { transform: scale(0.95); }

        .hidden { display: none !important; }
    </style>
</head>
<body>
<div id="app">
    <div class="hud">
        <div class="hud-box">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
        </div>
        <div class="hud-box target">
            <div class="label">Target</div>
            <div class="value" id="target">100</div>
        </div>
        <div class="hud-box moves" id="movesBox">
            <div class="label">Moves Left</div>
            <div class="value" id="moves">20</div>
        </div>
        <div class="hud-box">
            <div class="label">Level</div>
            <div class="value" id="level">1</div>
        </div>
    </div>
    <div class="progress-wrap">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>
    <div class="canvas-wrap">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div class="chain-popup" id="chainPopup"></div>
</div>

<!-- START SCREEN -->
<div class="overlay" id="startScreen">
    <h1>‚¨° HEXCHAIN</h1>
    <div class="rules">
        <b>üéØ Goal:</b> Reach the target score before moves run out.<br>
        <b>üëÜ Tap</b> a hex to add charge (+1).<br>
        <b>üí• Overflow:</b> When charge ‚â• capacity ‚Üí it explodes to neighbors.<br>
        <b>‚õìÔ∏è Chains:</b> Explosions can trigger more explosions. Longer chains = way more points!<br>
        <b>üß† Strategy:</b> Build up cells near each other, then trigger a big chain.
    </div>
    <button class="btn" id="startBtn">START GAME</button>
</div>

<!-- LEVEL UP SCREEN -->
<div class="overlay hidden" id="levelScreen">
    <h1>üéâ LEVEL UP!</h1>
    <div class="stats">
        <div class="big">Level <span id="nextLevel">2</span></div>
        <div class="sub">New target: <span id="nextTarget">180</span> pts</div>
    </div>
    <button class="btn" id="levelBtn">CONTINUE</button>
</div>

<!-- GAME OVER SCREEN -->
<div class="overlay hidden" id="gameOverScreen">
    <h1>GAME OVER</h1>
    <div class="stats">
        <div class="big"><span id="finalScore">0</span> pts</div>
        <div class="sub">Reached level <span id="finalLevel">1</span></div>
    </div>
    <button class="btn" id="retryBtn">TRY AGAIN</button>
</div>

<script>
(() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const targetEl = document.getElementById('target');
    const levelEl = document.getElementById('level');
    const movesEl = document.getElementById('moves');
    const movesBox = document.getElementById('movesBox');
    const progressFill = document.getElementById('progressFill');
    const chainPopup = document.getElementById('chainPopup');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const levelScreen = document.getElementById('levelScreen');

    const GRID_COLS = 7, GRID_ROWS = 7;
    let W, H, hexSize, offsetX, offsetY;
    let grid = [], score = 0, level = 1, moves = 0, target = 0;
    let gameState = 'start';
    let particles = [];
    let chainCount = 0;
    let hoverHex = null;

    const COLORS = ['#ff6ac1','#ff9a76','#ffd93d','#6bcb77','#4d96ff','#9b59b6','#e74c3c','#1abc9c'];
    const MAX_CAP = 6;

    function resize() {
        const wrap = canvas.parentElement;
        const ww = wrap.clientWidth;
        const wh = wrap.clientHeight;
        const dpr = window.devicePixelRatio || 1;

        // Calculate hex size to fit grid in available space
        const maxHexW = (ww - 40) / (GRID_COLS * 1.75 + 0.5);
        const maxHexH = (wh - 20) / (GRID_ROWS * 1.55 + 1);
        hexSize = Math.min(maxHexW, maxHexH, 42);

        const gridW = GRID_COLS * hexSize * 1.75;
        const gridH = GRID_ROWS * hexSize * 1.55 + hexSize * 0.8;

        canvas.style.width = Math.ceil(gridW + hexSize * 2) + 'px';
        canvas.style.height = Math.ceil(gridH + hexSize * 2) + 'px';
        canvas.width = Math.ceil(gridW + hexSize * 2) * dpr;
        canvas.height = Math.ceil(gridH + hexSize * 2) * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        W = parseFloat(canvas.style.width);
        H = parseFloat(canvas.style.height);
        offsetX = hexSize;
        offsetY = hexSize;
    }

    function hexToPixel(c, r) {
        return {
            x: offsetX + c * hexSize * 1.75,
            y: offsetY + r * hexSize * 1.55 + (c % 2 ? hexSize * 0.775 : 0)
        };
    }

    function getNeighbors(c, r) {
        const even = c % 2 === 0;
        const dirs = even
            ? [[-1,-1],[-1,0],[0,-1],[0,1],[1,-1],[1,0]]
            : [[-1,0],[-1,1],[0,-1],[0,1],[1,0],[1,1]];
        const out = [];
        for (const [dc, dr] of dirs) {
            const nc = c + dc, nr = r + dr;
            if (nc >= 0 && nc < GRID_COLS && nr >= 0 && nr < GRID_ROWS)
                out.push({ col: nc, row: nr });
        }
        return out;
    }

    function initGrid() {
        grid = [];
        for (let c = 0; c < GRID_COLS; c++) {
            grid[c] = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                const cap = Math.min(getNeighbors(c, r).length + 1, MAX_CAP);
                const maxInit = Math.max(1, cap - 2);
                grid[c][r] = {
                    charge: Math.floor(Math.random() * (maxInit + 1)),
                    cap,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    scale: 1, flash: 0
                };
            }
        }
    }

    function updateHUD() {
        scoreEl.textContent = score;
        targetEl.textContent = target;
        movesEl.textContent = moves;
        levelEl.textContent = level;
        const pct = Math.min(100, (score / target) * 100);
        progressFill.style.width = pct + '%';
        movesBox.classList.toggle('danger', moves <= 5);
    }

    function showChainPopup(chain) {
        const bonus = chain * chain * 10;
        chainPopup.textContent = `${chain}x CHAIN! +${bonus}`;
        chainPopup.className = 'chain-popup show';
        setTimeout(() => chainPopup.className = 'chain-popup fade', 600);
        setTimeout(() => chainPopup.className = 'chain-popup', 1000);
    }

    function addCharge(col, row) {
        if (gameState !== 'playing') return;
        const cell = grid[col][row];
        cell.charge++;
        cell.scale = 1.25;
        moves--;
        updateHUD();

        if (cell.charge >= cell.cap) {
            gameState = 'animating';
            chainCount = 0;
            setTimeout(() => processExplosions(), 180);
        } else {
            checkEnd();
        }
    }

    function processExplosions() {
        const toExplode = [];
        for (let c = 0; c < GRID_COLS; c++)
            for (let r = 0; r < GRID_ROWS; r++)
                if (grid[c][r].charge >= grid[c][r].cap)
                    toExplode.push({ col: c, row: r });

        if (!toExplode.length) {
            gameState = 'playing';
            checkEnd();
            return;
        }

        chainCount++;
        const bonus = chainCount * chainCount * 10;
        if (chainCount >= 2) showChainPopup(chainCount);

        for (const { col, row } of toExplode) {
            const cell = grid[col][row];
            const pos = hexToPixel(col, row);

            for (let i = 0; i < 10; i++) {
                const a = Math.random() * Math.PI * 2;
                const sp = 2 + Math.random() * 5;
                particles.push({
                    x: pos.x, y: pos.y,
                    vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
                    life: 1, color: cell.color,
                    size: 2 + Math.random() * 4
                });
            }

            cell.charge = 0;
            cell.flash = 1;
            cell.color = COLORS[Math.floor(Math.random() * COLORS.length)];

            for (const n of getNeighbors(col, row)) {
                grid[n.col][n.row].charge++;
                grid[n.col][n.row].scale = 1.3;
            }

            score += 10 + bonus;
        }

        updateHUD();
        setTimeout(() => processExplosions(), 280);
    }

    function checkEnd() {
        if (score >= target && gameState === 'playing') {
            gameState = 'levelup';
            level++;
            target = Math.floor(target * 1.8);
            document.getElementById('nextLevel').textContent = level;
            document.getElementById('nextTarget').textContent = target;
            levelScreen.classList.remove('hidden');
            return;
        }
        if (moves <= 0 && gameState === 'playing') {
            gameState = 'gameover';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            gameOverScreen.classList.remove('hidden');
        }
    }

    function pixelToHex(mx, my) {
        let best = null, dist = Infinity;
        for (let c = 0; c < GRID_COLS; c++) {
            for (let r = 0; r < GRID_ROWS; r++) {
                const p = hexToPixel(c, r);
                const d = Math.hypot(mx - p.x, my - p.y);
                if (d < hexSize * 0.85 && d < dist) {
                    dist = d;
                    best = { col: c, row: r };
                }
            }
        }
        return best;
    }

    function hexPath(cx, cy, size) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = Math.PI / 3 * i - Math.PI / 6;
            const x = cx + size * Math.cos(a);
            const y = cy + size * Math.sin(a);
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.closePath();
    }

    function toRGB(hex) {
        return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
    }

    function draw() {
        ctx.clearRect(0, 0, W * 2, H * 2);

        for (let c = 0; c < GRID_COLS; c++) {
            for (let r = 0; r < GRID_ROWS; r++) {
                const cell = grid[c][r];
                const pos = hexToPixel(c, r);
                const s = hexSize * 0.88 * cell.scale;
                const ratio = cell.charge / cell.cap;
                const [cr, cg, cb] = toRGB(cell.color);
                const isHover = hoverHex && hoverHex.col === c && hoverHex.row === r;

                // Glow for near-full cells
                if (ratio >= 0.8 || cell.flash > 0.05) {
                    ctx.shadowColor = cell.color;
                    ctx.shadowBlur = 15 + cell.flash * 20;
                }

                // Fill
                hexPath(pos.x, pos.y, s);
                const alpha = 0.12 + ratio * 0.55 + cell.flash * 0.3;
                ctx.fillStyle = `rgba(${cr},${cg},${cb},${alpha})`;
                ctx.fill();

                // Stroke
                const strokeA = isHover ? 0.9 : (0.25 + ratio * 0.5);
                ctx.strokeStyle = `rgba(${cr},${cg},${cb},${strokeA})`;
                ctx.lineWidth = isHover ? 2.5 : (1 + ratio * 1.5);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Charge indicator: filled fraction arc
                if (cell.charge > 0) {
                    const dotR = 4 + ratio * 3;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, dotR, 0, Math.PI * 2);
                    ctx.fillStyle = cell.color;
                    ctx.shadowColor = cell.color;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Number inside
                    ctx.fillStyle = '#050510';
                    ctx.font = `bold ${8 + ratio * 3}px 'JetBrains Mono'`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(cell.charge, pos.x, pos.y + 0.5);
                }

                // Capacity ring
                if (ratio >= 0.6) {
                    const pulse = 0.4 + Math.sin(Date.now() * 0.006) * 0.25;
                    hexPath(pos.x, pos.y, s + 5);
                    ctx.strokeStyle = `rgba(${cr},${cg},${cb},${pulse})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Hover highlight
                if (isHover && gameState === 'playing') {
                    hexPath(pos.x, pos.y, s + 2);
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.vx *= 0.95; p.vy *= 0.95;
            p.life -= 0.022;
            if (p.life <= 0) { particles.splice(i, 1); continue; }
            const [pr, pg, pb] = toRGB(p.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${pr},${pg},${pb},${p.life})`;
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 6;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Animate cells
        for (let c = 0; c < GRID_COLS; c++)
            for (let r = 0; r < GRID_ROWS; r++) {
                grid[c][r].scale += (1 - grid[c][r].scale) * 0.12;
                grid[c][r].flash *= 0.88;
            }
    }

    function loop() {
        draw();
        requestAnimationFrame(loop);
    }

    function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = parseFloat(canvas.style.width) / rect.width;
        const scaleY = parseFloat(canvas.style.height) / rect.height;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    canvas.addEventListener('click', e => {
        const { x, y } = getCanvasPos(e);
        const hex = pixelToHex(x, y);
        if (hex && gameState === 'playing') addCharge(hex.col, hex.row);
    });

    canvas.addEventListener('mousemove', e => {
        const { x, y } = getCanvasPos(e);
        hoverHex = pixelToHex(x, y);
        canvas.style.cursor = hoverHex && gameState === 'playing' ? 'pointer' : 'default';
    });

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const { x, y } = getCanvasPos(e);
        const hex = pixelToHex(x, y);
        if (hex && gameState === 'playing') addCharge(hex.col, hex.row);
    }, { passive: false });

    function startGame() {
        score = 0; level = 1; moves = 20; target = 100;
        particles = []; chainCount = 0;
        initGrid(); updateHUD();
        gameState = 'playing';
    }

    function nextLevel() {
        moves = 15 + level * 3;
        particles = [];
        initGrid(); updateHUD();
        gameState = 'playing';
    }

    document.getElementById('startBtn').addEventListener('click', () => {
        startScreen.classList.add('hidden');
        startGame();
    });

    document.getElementById('retryBtn').addEventListener('click', () => {
        gameOverScreen.classList.add('hidden');
        startGame();
    });

    document.getElementById('levelBtn').addEventListener('click', () => {
        levelScreen.classList.add('hidden');
        nextLevel();
    });

    window.addEventListener('resize', resize);
    resize();
    initGrid();
    loop();
})();
</script>
</body>
</html>
