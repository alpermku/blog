<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drift - Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#05050a;overflow:hidden;font-family:'JetBrains Mono',monospace;color:#fff;user-select:none;display:flex;justify-content:center;align-items:center;height:100vh}
        canvas{display:block;box-shadow:0 0 50px rgba(0,229,255,0.1)}
        .back-btn{position:fixed;top:14px;left:18px;z-index:20;font-family:'JetBrains Mono',monospace;font-size:13px;color:rgba(255,255,255,0.3);text-decoration:none;transition:color .2s;z-index:100}
        .back-btn:hover{color:#fff}
    </style>
</head>
<body>
    <a href="../games.html" class="back-btn">‚Üê Arcade</a>
    <canvas id="c"></canvas>
<script>
// ============================================================
//  D R I F T  ‚Äî  Neon Edition
//  Featuring: Fair path generation, High-fidelity car model,
//  Particle effects, Screen shake, and maximum juice.
// ============================================================

const C = document.getElementById('c');
const X = C.getContext('2d');
const W = C.width = window.innerWidth;
const H = C.height = window.innerHeight;

// ======================== TUNING ========================
const LANE_W = Math.min(W * 0.9, 600);
const LANE_X = (W - LANE_W) / 2;
const PLAYER_Y = H * 0.8;
const CAR_W = 26; 
const CAR_H = 44; 
// Hitbox is slightly smaller than visual car for fairness
const HITBOX_W = 20;
const HITBOX_H = 38;

const BASE_SPEED = 4;
const MAX_SPEED = 15;
const SPEED_RAMP = 0.04;

const NEAR_MISS_DIST = 45;
const GRAZE_DIST = 26;

// ======================== COLORS ========================
const THEME = {
    road: '#080812',
    player: '#00e5ff',
    obstacle: '#ff2255',
    nearMiss: '#44ffaa',
    graze: '#ffd700',
    shield: '#00e5ff',
    text: '#ffffff',
    accent: '#00e5ff',
};

const LEVEL_THEMES = [
    { name: 'IGNITION',    accent: '#00e5ff', obstacle: '#ff2255', bg: '#05050a' },
    { name: 'VELOCITY',    accent: '#44ffaa', obstacle: '#ff6633', bg: '#050a08' },
    { name: 'MOMENTUM',    accent: '#ffaa33', obstacle: '#ff2288', bg: '#0a0805' },
    { name: 'OVERDRIVE',   accent: '#c864ff', obstacle: '#ff4444', bg: '#08050a' },
    { name: 'HYPERDRIVE',  accent: '#ff6688', obstacle: '#ff0066', bg: '#0a0506' },
    { name: 'INFINITE',    accent: '#00ffcc', obstacle: '#ff1144', bg: '#050a0a' },
];

// ======================== AUDIO SYSTEM (Web Audio API) ========================
const Audio = {
    ctx: null,
    engineOsc: null,
    engineGain: null,
    init: function() {
        if (this.ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC();
        
        // Engine drone
        this.engineOsc = this.ctx.createOscillator();
        this.engineGain = this.ctx.createGain();
        this.engineOsc.type = 'sawtooth';
        this.engineOsc.frequency.value = 60;
        this.engineGain.gain.value = 0;
        
        // Lowpass filter for engine (muffles the sawtooth)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        
        this.engineOsc.connect(filter);
        filter.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
    },
    
    updateEngine: function(speedRatio) {
        if (!this.ctx) return;
        // speedRatio: 0 to 1
        // Pitch: 60Hz -> 200Hz
        const targetFreq = 60 + speedRatio * 140;
        this.engineOsc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1);
        
        // Volume: 0.05 -> 0.15 (subtle)
        // If dead or menu, volume 0
        const vol = (state === 'playing') ? 0.05 + speedRatio * 0.1 : 0;
        this.engineGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
    },
    
    play: function(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        if (type === 'coin') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1200, t);
            osc.frequency.exponentialRampToValueAtTime(1800, t + 0.1);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.start(t);
            osc.stop(t + 0.1);
        } else if (type === 'nearmiss') {
            // Noise burst
            const bufferSize = this.ctx.sampleRate * 0.2; // 200ms
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 1000;
            
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.4, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.ctx.destination);
            noise.start(t);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.exponentialRampToValueAtTime(40, t + 0.3);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.start(t);
            osc.stop(t + 0.3);
        } else if (type === 'die') {
            // Crash noise
            const bufferSize = this.ctx.sampleRate * 1.0;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(1, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.0);
            
            noise.connect(noiseGain);
            noiseGain.connect(this.ctx.destination);
            noise.start(t);
        } else if (type === 'powerup') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, t);
            osc.frequency.linearRampToValueAtTime(800, t + 0.1);
            osc.frequency.linearRampToValueAtTime(1200, t + 0.2);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t);
            osc.stop(t + 0.3);
        }
    }
};

// ======================== STATE ========================
let state = 'menu';
let score = 0, highScore = 0, distance = 0;
let speed = BASE_SPEED;
let playerX = W / 2;
let targetX = W / 2;
let shields = 3;
let level = 0;
let combo = 0, maxCombo = 0, totalNearMisses = 0;
let frame = 0;
let obstacles = [], orbs = [], particles = [], floats = [], powerups = [];
let trail = []; // Tire tracks
let shakeTime = 0, shakeIntensity = 0;
let flashAlpha = 0, flashColor = '#fff';
let levelUpTimer = 0;
let invincible = 0;
let streakMultiplier = 1;
let lastNearMissFrame = -999;
let activePower = null;
let magnetActive = false;
let carTilt = 0; // Visual banking

// Pathfinding state
let lastGapCenter = LANE_W / 2; 

const POWER_TYPES = [
    { type: 'magnet', icon: 'üß≤', color: '#ffd700', desc: 'MAGNET', duration: 300 },
    { type: 'shield', icon: 'üõ°Ô∏è', color: '#00e5ff', desc: '+SHIELD', duration: 0 },
    { type: 'slow',   icon: '‚è≥', color: '#44ffaa', desc: 'SLOW',   duration: 360 },
];

try { highScore = parseInt(localStorage.getItem('drift_hi')) || 0; } catch(e) {}

// ======================== INPUT ========================
let inputX = null;
let keys = { left: false, right: false };

C.addEventListener('mousemove', e => { if (state === 'playing') inputX = e.clientX; });
C.addEventListener('click', () => { if (state !== 'playing') startGame(); });
C.addEventListener('touchstart', e => { 
    if (state !== 'playing') { startGame(); return; }
    inputX = e.touches[0].clientX; 
}, { passive: false });
C.addEventListener('touchmove', e => { 
    e.preventDefault(); 
    inputX = e.touches[0].clientX; 
}, { passive: false });

document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === ' ' || e.key === 'Enter') { if (state !== 'playing') startGame(); }
});
document.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
});

// ======================== GAME FLOW ========================
function startGame() {
    Audio.init(); // Init audio on user interaction
    state = 'playing';
    score = 0; distance = 0; speed = BASE_SPEED;
    playerX = W / 2; targetX = W / 2; lastGapCenter = LANE_W / 2;
    shields = 3; level = 0; combo = 0; maxCombo = 0;
    obstacles = []; orbs = []; particles = []; floats = []; trail = []; powerups = [];
    activePower = null; invincible = 0;
    streakMultiplier = 1;
}

function die() {
    state = 'dead';
    shakeTime = 40; shakeIntensity = 10;
    flashAlpha = 0.6; flashColor = '#ff0033';
    
    // Massive Car Explosion
    for (let i = 0; i < 60; i++) {
        const a = Math.random() * Math.PI * 2, s = 2 + Math.random() * 8;
        particles.push({ 
            x: playerX, y: PLAYER_Y, 
            dx: Math.cos(a)*s, dy: Math.sin(a)*s, 
            life: 1.2, decay: 0.01 + Math.random()*0.02,
            color: Math.random() < 0.5 ? THEME.player : '#ffffff', 
            size: 3 + Math.random()*4 
        });
    }
    if (score > highScore) { highScore = score; try { localStorage.setItem('drift_hi', highScore); } catch(e) {} }
    Audio.play('die');
}

// ======================== SPAWNING (FAIR) ========================
function spawnObstacle() {
    const cfg = LEVEL_THEMES[level % LEVEL_THEMES.length];
    
    // Reachable distance calculation
    const reachable = 280; 
    const minGap = 110; // Slightly wider for car
    
    let gapCenter = lastGapCenter + (Math.random() - 0.5) * reachable * 2;
    gapCenter = Math.max(minGap/2 + 20, Math.min(LANE_W - minGap/2 - 20, gapCenter));
    lastGapCenter = gapCenter;
    
    // 60% Gate (Two walls), 40% Block
    const isGate = Math.random() > 0.4;
    
    if (isGate) {
        const gapW = minGap + Math.random() * 50;
        const leftW = gapCenter - gapW / 2;
        const rightX = gapCenter + gapW / 2;
        const rightW = LANE_W - rightX;
        
        if (leftW > 10) obstacles.push(createObstacle(LANE_X, -40, leftW, 30, cfg.obstacle));
        if (rightW > 10) obstacles.push(createObstacle(LANE_X + rightX, -40, rightW, 30, cfg.obstacle));
        
        if (Math.random() < 0.4) orbs.push({ x: LANE_X + gapCenter, y: -40, r: 7, collected: false });
    } else {
        const side = Math.random() < 0.5 ? 'left' : 'right';
        const blockW = Math.random() * (LANE_W * 0.35) + 60;
        
        if (side === 'left') {
            let w = Math.min(blockW, gapCenter - minGap/2);
            obstacles.push(createObstacle(LANE_X, -40, w, 30, cfg.obstacle));
        } else {
            let x = Math.max(LANE_X + LANE_W - blockW, LANE_X + gapCenter + minGap/2);
            obstacles.push(createObstacle(x, -40, LANE_X + LANE_W - x, 30, cfg.obstacle));
        }
    }

    if (Math.random() < 0.05) {
        const pt = POWER_TYPES[Math.floor(Math.random() * POWER_TYPES.length)];
        powerups.push({ x: LANE_X + Math.random() * LANE_W, y: -100, r: 14, ...pt, collected: false });
    }
}

function createObstacle(x, y, w, h, c) {
    return { x, y, w, h, color: c, counted: false };
}

// ======================== UPDATE ========================
function update() {
    if (state !== 'playing') return;
    frame++;
    
    const slowActive = activePower && activePower.type === 'slow';
    const effectiveSpeed = slowActive ? speed * 0.6 : speed;
    if (!slowActive) speed = Math.min(speed + SPEED_RAMP / 60, MAX_SPEED);
    distance += effectiveSpeed;

    // Level progression
    const newLevel = Math.min(Math.floor(distance / 1000), LEVEL_THEMES.length - 1);
    if (newLevel > level) {
        level = newLevel;
        levelUpTimer = 140;
        flashAlpha = 0.25; flashColor = LEVEL_THEMES[level].accent;
        floats.push({ x: W/2, y: H/3, text: LEVEL_THEMES[level].name, color: LEVEL_THEMES[level].accent, size: 24, life: 3, dy: -0.2 });
    }

    // Player Movement
    if (inputX !== null) targetX = inputX;
    if (keys.left) targetX -= 10;
    if (keys.right) targetX += 10;
    targetX = Math.max(LANE_X + 20, Math.min(LANE_X + LANE_W - 20, targetX));
    
    // Smooth physics
    const diff = targetX - playerX;
    playerX += diff * 0.15;
    carTilt = diff * 0.04; // Banking effect
    carTilt = Math.max(-0.6, Math.min(0.6, carTilt));

    // Tire tracks (Trail)
    if (frame % 3 === 0) {
        trail.push({ x: playerX - 10, y: PLAYER_Y + 18, life: 1, type: 'tire' });
        trail.push({ x: playerX + 10, y: PLAYER_Y + 18, life: 1, type: 'tire' });
    }
    // Speed lines
    if (Math.random() < speed * 0.05) {
        particles.push({ 
            x: LANE_X + Math.random()*LANE_W, y: -10, 
            dx: 0, dy: effectiveSpeed * 1.5, 
            life: 0.6, color: 'rgba(255,255,255,0.1)', size: 1, type: 'line', h: 30 + Math.random()*50
        });
    }

    // Spawn
    if (distance % 250 < effectiveSpeed) spawnObstacle();

    // Timers
    if (activePower) {
        activePower.timer--;
        if (activePower.type === 'magnet') magnetActive = true;
        if (activePower.timer <= 0) activePower = null;
    }
    if (invincible > 0) invincible--;
    if (shakeTime > 0) shakeTime--;
    if (flashAlpha > 0) flashAlpha -= 0.02;
    if (levelUpTimer > 0) levelUpTimer--;

    // Collision & Logic
    const checkHit = (e, isObs) => {
        // Simple AABB
        if (isObs) {
            return playerX + HITBOX_W/2 > e.x && playerX - HITBOX_W/2 < e.x + e.w &&
                   PLAYER_Y + HITBOX_H/2 > e.y && PLAYER_Y - HITBOX_H/2 < e.y + e.h;
        } else {
            return Math.hypot(playerX - e.x, PLAYER_Y - e.y) < HITBOX_W + e.r;
        }
    };

    // Obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.y += effectiveSpeed;
        if (o.y > H + 50) { obstacles.splice(i, 1); continue; }

        if (checkHit(o, true)) {
            if (invincible > 0) continue;
            shields--;
            invincible = 60;
            shakeTime = 15; shakeIntensity = 5;
            combo = 0; streakMultiplier = 1;
            floats.push({ x: playerX, y: PLAYER_Y - 40, text: '-SHIELD', color: '#ff2255', size: 14, life: 1, dy: -1 });
            
            // Shield break particles
            for(let j=0; j<10; j++) {
                const a=Math.random()*Math.PI*2;
                particles.push({x:playerX, y:PLAYER_Y, dx:Math.cos(a)*4, dy:Math.sin(a)*4, life:0.6, color:'#00e5ff', size:2});
            }
            
            if (shields < 0) { die(); return; }
            Audio.play('hit');
        } else if (!o.counted && o.y > PLAYER_Y) {
            // Near miss
            const closestX = Math.max(o.x, Math.min(o.x + o.w, playerX));
            const dist = Math.abs(playerX - closestX);
            // distance from center of car to edge of block. Car half-width is ~13.
            // So if dist < 13, collision. If dist < 13 + 30 = 43, near miss.
            const threshold = CAR_W/2 + NEAR_MISS_DIST;
            
            if (dist < threshold) {
                o.counted = true;
                const isGraze = dist < CAR_W/2 + GRAZE_DIST;
                
                combo++;
                streakMultiplier = Math.min(1 + combo * 0.2, 5);
                const pts = Math.round((isGraze ? 200 : 100) * streakMultiplier);
                score += pts;
                
                const color = isGraze ? THEME.graze : THEME.nearMiss;
                floats.push({ x: playerX, y: PLAYER_Y-40, text: isGraze?'GRAZE!':'NEAR!', color: color, size: isGraze?12:10, life: 0.8, dy: -1.5 });
                floats.push({ x: playerX, y: PLAYER_Y-25, text: `+${pts}`, color: '#fff', size: 10, life: 0.8, dy: -1.5 });
                Audio.play('nearmiss');
                
                // Spark particles
                const side = playerX < closestX ? 1 : -1; // Sparks fly opposite to wall
                for(let j=0; j<(isGraze?8:4); j++) {
                    const a = (side>0?0:Math.PI) + (Math.random()-0.5);
                    particles.push({
                        x: closestX, y: PLAYER_Y,
                        dx: Math.cos(a)*5, dy: (Math.random()-0.5)*5,
                        life: 0.5, color: color, size: 2
                    });
                }
            }
        }
    }

    // Collectibles
    [orbs, powerups].forEach(list => {
        for (let i = list.length - 1; i >= 0; i--) {
            const e = list[i];
            e.y += effectiveSpeed;
            if (activePower?.type === 'magnet' && !e.type) { // Magnet pulls orbs
                const d = Math.hypot(playerX - e.x, PLAYER_Y - e.y);
                if (d < 250) {
                    e.x += (playerX - e.x) * 0.15;
                    e.y += (PLAYER_Y - e.y) * 0.15;
                }
            }
            if (checkHit(e, false)) {
                e.collected = true;
                if (e.type) {
                     if (e.type === 'shield') shields = Math.min(shields+1, 5);
                     else activePower = { type: e.type, timer: e.duration };
                     floats.push({ x: e.x, y: e.y, text: e.desc, color: e.color, size: 12, life: 1, dy: -1 });
                } else {
                     score += Math.round(50 * streakMultiplier);
                }
                list.splice(i, 1);
            } else if (e.y > H + 50) list.splice(i, 1);
        }
    });

    score += Math.round(effectiveSpeed * 0.2);

    // Update VFX
    particles.forEach(p => { p.x += p.dx; p.y += p.dy; p.life -= 0.03; });
    particles = particles.filter(p => p.life > 0);
    trail.forEach(t => t.life -= 0.02);
    trail = trail.filter(t => t.life > 0);
    floats.forEach(f => { f.y += f.dy; f.life -= 0.02; });
    floats = floats.filter(f => f.life > 0);
}

// ======================== DRAW ========================
function draw() {
    const cfg = LEVEL_THEMES[level % LEVEL_THEMES.length];
    
    X.save();
    if (shakeTime > 0) {
        const s = shakeIntensity * (shakeTime / 30);
        X.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
    }

    // BG
    X.fillStyle = cfg.bg;
    X.fillRect(0, 0, W, H);
    
    // Grid
    const off = (distance % 50);
    X.strokeStyle = 'rgba(255,255,255,0.03)';
    X.lineWidth = 1;
    for(let y=off; y<H; y+=50) { X.beginPath(); X.moveTo(LANE_X, y); X.lineTo(LANE_X+LANE_W, y); X.stroke(); }
    
    // Lane Edges (Neon Glow)
    X.shadowBlur = 15; X.shadowColor = cfg.accent;
    X.strokeStyle = cfg.accent; X.lineWidth = 3;
    X.beginPath(); X.moveTo(LANE_X,0); X.lineTo(LANE_X,H); X.stroke();
    X.beginPath(); X.moveTo(LANE_X+LANE_W,0); X.lineTo(LANE_X+LANE_W,H); X.stroke();
    X.shadowBlur = 0;

    // Tire Tracks
    trail.forEach(t => {
        X.fillStyle = `rgba(0, 229, 255, ${t.life * 0.3})`;
        X.fillRect(t.x - 2, t.y, 4, 4);
    });

    // Speed Lines
    particles.forEach(p => {
        if(p.type === 'line') {
            X.fillStyle = p.color;
            X.fillRect(p.x, p.y, p.size, p.h);
        }
    });

    // Player (THE CAR)
    if (state !== 'dead') {
        X.save();
        X.translate(playerX, PLAYER_Y);
        X.rotate(carTilt); 
        if (invincible % 10 < 5) drawCar(cfg.accent);
        X.restore();
    }

    // Obstacles
    obstacles.forEach(o => {
        // Top face
        X.fillStyle = o.color;
        X.shadowBlur = 10; X.shadowColor = o.color;
        X.fillRect(o.x, o.y, o.w, o.h);
        X.shadowBlur = 0;
        // Front face (pseudo-3D)
        X.fillStyle = 'rgba(0,0,0,0.3)';
        X.fillRect(o.x, o.y + o.h - 5, o.w, 5);
        // Highlight
        X.fillStyle = '#fff';
        X.fillRect(o.x, o.y, o.w, 2);
    });

    // Orbs & Powerups
    orbs.forEach(o => {
        X.shadowBlur = 10; X.shadowColor = '#ffd700';
        X.fillStyle = '#ffd700'; X.beginPath(); X.arc(o.x, o.y, o.r, 0, Math.PI*2); X.fill();
        X.shadowBlur = 0;
    });
    powerups.forEach(p => {
        X.shadowBlur = 15; X.shadowColor = p.color;
        X.fillStyle = p.color; X.beginPath(); X.arc(p.x, p.y, p.r, 0, Math.PI*2); X.fill();
        X.shadowBlur = 0;
        X.fillStyle = '#000'; X.font = '14px serif'; X.textAlign='center'; X.fillText(p.icon, p.x, p.y+5);
    });

    // Particles (Sparks/Debris)
    particles.forEach(p => {
        if (p.type === 'line') return;
        X.globalAlpha = p.life;
        X.fillStyle = p.color;
        X.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    });
    X.globalAlpha = 1;

    // Flash
    if (flashAlpha > 0) {
        X.globalAlpha = flashAlpha;
        X.fillStyle = flashColor;
        X.fillRect(0,0,W,H);
        X.globalAlpha = 1;
    }

    // Floats
    floats.forEach(f => {
        X.globalAlpha = f.life;
        X.fillStyle = f.color;
        X.shadowBlur = 5; X.shadowColor = f.color;
        X.font = `${f.size}px "Press Start 2P"`;
        X.textAlign = 'center';
        X.fillText(f.text, f.x, f.y);
        X.shadowBlur = 0;
    });
    X.globalAlpha = 1;

    // HUD
    drawHUD();
    
    if (state === 'menu') drawMenu();
    if (state === 'dead') drawDeath();

    X.restore();
}

function drawCar(accent) {
    // Glow
    X.shadowBlur = 20; X.shadowColor = accent;
    
    // Body
    X.fillStyle = '#000';
    X.beginPath();
    X.roundRect(-CAR_W/2, -CAR_H/2, CAR_W, CAR_H, 4);
    X.fill();
    
    X.fillStyle = accent;
    // Hood lines
    X.fillRect(-CAR_W/2 + 2, -CAR_H/2 + 2, 2, CAR_H - 4);
    X.fillRect(CAR_W/2 - 4, -CAR_H/2 + 2, 2, CAR_H - 4);
    
    // Windshield
    X.fillStyle = '#000';
    X.beginPath();
    X.moveTo(-CAR_W/2 + 4, -5);
    X.lineTo(CAR_W/2 - 4, -5);
    X.lineTo(CAR_W/2 - 2, 5);
    X.lineTo(-CAR_W/2 + 2, 5);
    X.fill();
    
    // Headlights (Beams)
    X.globalAlpha = 0.3;
    X.fillStyle = '#fff';
    X.beginPath(); X.moveTo(-8, -CAR_H/2); X.lineTo(-20, -150); X.lineTo(0, -150); X.fill();
    X.beginPath(); X.moveTo(8, -CAR_H/2); X.lineTo(20, -150); X.lineTo(0, -150); X.fill();
    X.globalAlpha = 1;
    
    // Rear Lights (Red Trails)
    X.fillStyle = '#ff0000';
    X.shadowColor = '#ff0000';
    X.fillRect(-10, CAR_H/2 - 2, 6, 3);
    X.fillRect(4, CAR_H/2 - 2, 6, 3);
    
    X.shadowBlur = 0;
    
    // Shields
    if (shields > 0) {
        X.strokeStyle = THEME.shield;
        X.lineWidth = 2;
        X.globalAlpha = 0.6;
        X.beginPath(); X.arc(0, 0, CAR_H/2 + 8, 0, Math.PI*2); X.stroke();
        X.globalAlpha = 1;
    }
}

function drawHUD() {
    X.fillStyle = '#fff';
    X.font = '14px "Press Start 2P"';
    X.textAlign = 'left';
    X.fillText(`SCORE ${score.toLocaleString()}`, 20, 30);
    X.textAlign = 'right';
    X.fillText(`LV ${level+1}`, W-20, 30);
    
    // Speed Bar
    const barH = 100;
    const fillH = (speed / MAX_SPEED) * barH;
    X.fillStyle = 'rgba(255,255,255,0.1)';
    X.fillRect(W - 25, H/2 - barH/2, 6, barH);
    X.fillStyle = '#00e5ff';
    X.fillRect(W - 25, H/2 + barH/2 - fillH, 6, fillH);
}

function drawMenu() {
    X.fillStyle = 'rgba(0,0,0,0.85)';
    X.fillRect(0,0,W,H);
    X.fillStyle = THEME.accent;
    X.textAlign = 'center';
    X.font = '32px "Press Start 2P"';
    X.shadowColor = THEME.accent; X.shadowBlur = 40;
    X.fillText('DRIFT', W/2, H*0.4);
    X.shadowBlur = 0;
    X.fillStyle = '#fff';
    X.font = '10px "Press Start 2P"';
    X.fillText('CLICK / TAP TO START', W/2, H*0.6);
}

function drawDeath() {
    X.fillStyle = 'rgba(20,0,0,0.8)';
    X.fillRect(0,0,W,H);
    X.fillStyle = '#ff2255';
    X.textAlign = 'center';
    X.font = '24px "Press Start 2P"';
    X.fillText('CRASHED', W/2, H*0.4);
    X.fillStyle = '#fff';
    X.font = '12px "Press Start 2P"';
    X.fillText(`SCORE: ${score.toLocaleString()}`, W/2, H*0.5);
    X.fillStyle = 'rgba(255,255,255,0.5)';
    X.font = '10px "Press Start 2P"';
    X.fillText('TAP TO RETRY', W/2, H*0.7);
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
