<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drift - Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap');
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#05050a;overflow:hidden;font-family:'JetBrains Mono',monospace;color:#fff;user-select:none;display:flex;justify-content:center;align-items:center;height:100vh}
        canvas{display:block}
        .back-btn{position:fixed;top:14px;left:18px;z-index:20;font-family:'JetBrains Mono',monospace;font-size:13px;color:rgba(255,255,255,0.3);text-decoration:none;transition:color .2s;z-index:100}
        .back-btn:hover{color:#fff}
    </style>
</head>
<body>
    <a href="../games.html" class="back-btn">‚Üê Arcade</a>
    <canvas id="c"></canvas>
<script>
// ============================================================
//  D R I F T  ‚Äî  Refined
//  Fixes: Fair path generation (no impossible walls),
//  Reduced visual noise, Better hitboxes.
// ============================================================

const C = document.getElementById('c');
const X = C.getContext('2d');
const W = C.width = window.innerWidth;
const H = C.height = window.innerHeight;

// ======================== TUNING ========================
const LANE_W = Math.min(W * 0.85, 600); // Wider road for better playability
const LANE_X = (W - LANE_W) / 2;
const PLAYER_Y = H * 0.8;
const PLAYER_R = 8; // Smaller player hitbox

const BASE_SPEED = 3.5;
const SPEED_RAMP = 0.05; 
const MAX_SPEED = 12;

const NEAR_MISS_DIST = 40; // Generous near-miss zone
const GRAZE_DIST = 22;

const SPAWN_INTERVAL_BASE = 50; 
const MIN_GAP_WIDTH = 100; // Minimum clickable space

// ======================== COLORS ========================
const THEME = {
    road: '#080810',
    roadLine: 'rgba(255,255,255,0.03)',
    player: '#00e5ff',
    obstacle: '#ff2255',
    nearMiss: '#44ffaa',
    graze: '#ffd700',
    shield: '#00e5ff',
    text: '#ffffff',
    accent: '#00e5ff',
};

const LEVEL_THEMES = [
    { name: 'IGNITION',    accent: '#00e5ff', obstacle: '#ff2255' },
    { name: 'VELOCITY',    accent: '#44ffaa', obstacle: '#ff6633' },
    { name: 'MOMENTUM',    accent: '#ffaa33', obstacle: '#ff2288' },
    { name: 'OVERDRIVE',   accent: '#c864ff', obstacle: '#ff4444' },
    { name: 'HYPERDRIVE',  accent: '#ff6688', obstacle: '#ff0066' },
    { name: 'INFINITE',    accent: '#00ffcc', obstacle: '#ff1144' },
];

// ======================== STATE ========================
let state = 'menu';
let score = 0, highScore = 0, distance = 0;
let speed = BASE_SPEED;
let playerX = W / 2;
let targetX = W / 2;
let shields = 3;
let level = 0;
let combo = 0, maxCombo = 0, totalNearMisses = 0;
let frame = 0, spawnTimer = 0;
let obstacles = [], orbs = [], particles = [], floats = [], trail = [], powerups = [];
let shakeTime = 0;
let flashAlpha = 0, flashColor = '#fff';
let levelUpTimer = 0;
let invincible = 0;
let streakMultiplier = 1;
let lastNearMissFrame = -999;
let activePower = null;
let magnetActive = false;

// Pathfinding state to ensure playability
let lastGapCenter = LANE_W / 2; 

const POWER_TYPES = [
    { type: 'magnet', icon: 'üß≤', color: '#ffd700', desc: 'MAGNET', duration: 300 },
    { type: 'shield', icon: 'üõ°Ô∏è', color: '#00e5ff', desc: '+SHIELD', duration: 0 },
    { type: 'slow',   icon: '‚è≥', color: '#44ffaa', desc: 'SLOW',   duration: 360 },
];

try { highScore = parseInt(localStorage.getItem('drift_hi')) || 0; } catch(e) {}

// ======================== INPUT ========================
let inputX = null;
let keys = { left: false, right: false };

C.addEventListener('mousemove', e => { if (state === 'playing') inputX = e.clientX; });
C.addEventListener('click', () => { if (state !== 'playing') startGame(); });
C.addEventListener('touchstart', e => { 
    if (state !== 'playing') { startGame(); return; }
    inputX = e.touches[0].clientX; 
}, { passive: false });
C.addEventListener('touchmove', e => { 
    e.preventDefault(); 
    inputX = e.touches[0].clientX; 
}, { passive: false });

document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === ' ' || e.key === 'Enter') { if (state !== 'playing') startGame(); }
});
document.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
});

// ======================== GAME FLOW ========================
function startGame() {
    state = 'playing';
    score = 0; distance = 0; speed = BASE_SPEED;
    playerX = W / 2; targetX = W / 2; lastGapCenter = LANE_W / 2;
    shields = 3; level = 0; combo = 0; maxCombo = 0;
    obstacles = []; orbs = []; particles = []; floats = []; trail = []; powerups = [];
    activePower = null; invincible = 0;
    streakMultiplier = 1;
}

function die() {
    state = 'dead';
    shakeTime = 30;
    for (let i = 0; i < 40; i++) {
        const a = Math.random() * Math.PI * 2, s = 2 + Math.random() * 6;
        particles.push({ x: playerX, y: PLAYER_Y, dx: Math.cos(a)*s, dy: Math.sin(a)*s, life: 1, color: THEME.player, size: 3 });
    }
    if (score > highScore) { highScore = score; try { localStorage.setItem('drift_hi', highScore); } catch(e) {} }
}

// ======================== SPAWNING (FAIR) ========================
function spawnObstacle() {
    const cfg = LEVEL_THEMES[level % LEVEL_THEMES.length];
    
    // Calculate max reachable distance sideways based on time between spawns
    // Player lateral speed approx 12px/frame max (damped), safe bet is ~8px/frame
    // Gap interval (pixels vertically) is approx 250px
    // Time to reach = 250 / speed. At max speed 12, ~20 frames. 20 * 8 = 160px reachable.
    // We constrain the new gap to be within reachable distance of the last gap.
    
    const reachable = 300; // Generous lateral reach
    const minGap = MIN_GAP_WIDTH;
    
    // Determine new gap position centered around last gap, but clamped to road
    let gapCenter = lastGapCenter + (Math.random() - 0.5) * reachable * 2;
    gapCenter = Math.max(minGap/2 + 20, Math.min(LANE_W - minGap/2 - 20, gapCenter));
    
    lastGapCenter = gapCenter;
    
    // 70% chance to spawn a "gap" type (two walls), 30% single block
    const isGate = Math.random() > 0.3;
    
    if (isGate) {
        // Two walls with a gap in the middle
        const gapW = minGap + Math.random() * 60;
        const leftW = gapCenter - gapW / 2;
        const rightX = gapCenter + gapW / 2;
        const rightW = LANE_W - rightX;
        
        // Left wall
        if (leftW > 10) {
            obstacles.push({ x: LANE_X, y: -40, w: leftW, h: 25, color: cfg.obstacle, counted: false });
        }
        // Right wall
        if (rightW > 10) {
            obstacles.push({ x: LANE_X + rightX, y: -40, w: rightW, h: 25, color: cfg.obstacle, counted: false });
        }
        
        // Spawn goodie in the gap
        if (Math.random() < 0.4) {
            orbs.push({ x: LANE_X + gapCenter, y: -40, r: 7, collected: false });
        }
    } else {
        // Single block, but placed AWAY from the gap center we chose (to force steering)
        // Actually, easiest to just treat it as a gate with one missing wall
        const side = Math.random() < 0.5 ? 'left' : 'right';
        const blockW = Math.random() * (LANE_W * 0.4) + 50;
        
        if (side === 'left') {
            // Block on left, gap is on right
            // Ensure block doesn't cover our gapCenter
            let w = Math.min(blockW, gapCenter - minGap/2);
             obstacles.push({ x: LANE_X, y: -40, w: w, h: 25, color: cfg.obstacle, counted: false });
        } else {
            // Block on right
            let x = Math.max(LANE_X + LANE_W - blockW, LANE_X + gapCenter + minGap/2);
            obstacles.push({ x: x, y: -40, w: LANE_X + LANE_W - x, h: 25, color: cfg.obstacle, counted: false });
        }
    }

    // Power-up
    if (Math.random() < 0.05) {
        const pt = POWER_TYPES[Math.floor(Math.random() * POWER_TYPES.length)];
        powerups.push({ x: LANE_X + Math.random() * LANE_W, y: -100, r: 12, ...pt, collected: false });
    }
}

// ======================== UPDATE ========================
function update() {
    if (state !== 'playing') return;
    frame++;
    
    // Speed control
    const slowActive = activePower && activePower.type === 'slow';
    const effectiveSpeed = slowActive ? speed * 0.6 : speed;
    if (!slowActive) speed = Math.min(speed + SPEED_RAMP / 60, MAX_SPEED);
    distance += effectiveSpeed;

    // Level up
    const newLevel = Math.min(Math.floor(distance / 800), LEVEL_THEMES.length - 1);
    if (newLevel > level) {
        level = newLevel;
        levelUpTimer = 120;
        flashAlpha = 0.2; flashColor = LEVEL_THEMES[level].accent;
    }

    // Player Movement
    if (inputX !== null) targetX = inputX;
    if (keys.left) targetX -= 9;
    if (keys.right) targetX += 9;
    
    // Clamp target to road
    targetX = Math.max(LANE_X + PLAYER_R, Math.min(LANE_X + LANE_W - PLAYER_R, targetX));
    
    // Smooth follow
    playerX += (targetX - playerX) * 0.15;

    // Spawning
    // Spawn based on DISTANCE, not TIME, to keep gaps consistent regardless of speed
    // Gap ~250px vertical
    if (distance % 250 < effectiveSpeed) {
        spawnObstacle();
    }

    // Update entities
    if (activePower) {
        activePower.timer--;
        if (activePower.type === 'magnet') magnetActive = true;
        if (activePower.timer <= 0) activePower = null;
    }
    if (invincible > 0) invincible--;
    if (shakeTime > 0) shakeTime--;
    if (flashAlpha > 0) flashAlpha -= 0.02;
    if (levelUpTimer > 0) levelUpTimer--;

    // Move & Collision
    const moveEntity = (list, isObstacle) => {
        for (let i = list.length - 1; i >= 0; i--) {
            const e = list[i];
            e.y += effectiveSpeed;
            if (e.y > H + 50) { list.splice(i, 1); continue; }
            
            // Collision logic
            if (e.collected) continue;
            
            // Player AABB vs Rect (Obstacle) or Circle (Orb)
            let hit = false;
            if (isObstacle) {
                 hit = playerX + PLAYER_R > e.x && playerX - PLAYER_R < e.x + e.w &&
                       PLAYER_Y + PLAYER_R > e.y && PLAYER_Y - PLAYER_R < e.y + e.h;
            } else {
                 const d = Math.hypot(playerX - e.x, PLAYER_Y - e.y);
                 hit = d < PLAYER_R + e.r + 5;
            }

            if (hit) {
                if (isObstacle) {
                    if (invincible > 0) continue;
                    shields--;
                    invincible = 60;
                    shakeTime = 15;
                    combo = 0; streakMultiplier = 1;
                    floats.push({ x: playerX, y: PLAYER_Y - 30, text: '-SHIELD', color: '#ff2255', size: 14, life: 1, dy: -1 });
                    if (shields < 0) { die(); return; }
                } else {
                    // Collectible
                    e.collected = true;
                    if (e.type) { // Powerup
                        if (e.type === 'shield') shields = Math.min(shields+1, 5);
                        else activePower = { type: e.type, timer: e.duration };
                        floats.push({ x: e.x, y: e.y, text: e.desc, color: e.color, size: 12, life: 1, dy: -1 });
                    } else { // Orb
                        score += Math.round(50 * streakMultiplier);
                    }
                }
            } else if (isObstacle && !e.counted && e.y > PLAYER_Y + 10) {
                // Near miss check logic
                e.counted = true;
                const closestX = Math.max(e.x, Math.min(e.x + e.w, playerX));
                const dist = Math.abs(playerX - closestX);
                if (dist < NEAR_MISS_DIST) {
                    combo++;
                    streakMultiplier = Math.min(1 + combo * 0.2, 5);
                    const pts = Math.round((dist < GRAZE_DIST ? 200 : 100) * streakMultiplier);
                    score += pts;
                    floats.push({ x: playerX, y: PLAYER_Y-20, text: `+${pts}`, color: '#44ffaa', size: 10, life: 0.8, dy: -1 });
                }
            }
        }
    };

    moveEntity(obstacles, true);
    moveEntity(orbs, false);
    moveEntity(powerups, false);

    // Magnet
    if (magnetActive) {
        orbs.forEach(o => {
            if (o.collected) return;
            const d = Math.hypot(playerX - o.x, PLAYER_Y - o.y);
            if (d < 200) {
                o.x += (playerX - o.x) * 0.1;
                o.y += (PLAYER_Y - o.y) * 0.1;
            }
        });
    }

    score += Math.round(effectiveSpeed * 0.2);
    
    // Floats & Particles
    floats.forEach(f => { f.y += f.dy; f.life -= 0.02; });
    floats = floats.filter(f => f.life > 0);
    particles.forEach(p => { p.x += p.dx; p.y += p.dy; p.life -= 0.05; });
    particles = particles.filter(p => p.life > 0);
}

// ======================== DRAW ========================
function draw() {
    const cfg = LEVEL_THEMES[level % LEVEL_THEMES.length];
    
    X.save();
    if (shakeTime > 0) {
        const s = shakeTime * 0.5;
        X.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
    }

    // Clean Background
    X.fillStyle = '#05050a';
    X.fillRect(0, 0, W, H);

    // Subtle Grid
    X.strokeStyle = 'rgba(255,255,255,0.02)';
    X.lineWidth = 1;
    const offset = (distance % 50);
    for (let y = offset; y < H; y += 50) {
        X.beginPath(); X.moveTo(LANE_X, y); X.lineTo(LANE_X + LANE_W, y); X.stroke();
    }
    
    // Lane Edges
    X.strokeStyle = cfg.accent;
    X.lineWidth = 2;
    X.beginPath(); X.moveTo(LANE_X, 0); X.lineTo(LANE_X, H); X.stroke();
    X.beginPath(); X.moveTo(LANE_X+LANE_W, 0); X.lineTo(LANE_X+LANE_W, H); X.stroke();

    // Player
    if (state !== 'dead') {
        if (invincible % 10 < 5) {
            X.fillStyle = THEME.player;
            X.shadowColor = THEME.player;
            X.shadowBlur = 15;
            X.beginPath(); X.arc(playerX, PLAYER_Y, PLAYER_R, 0, Math.PI*2); X.fill();
            X.shadowBlur = 0;
            
            // Shields ring
            if (shields > 0) {
                X.strokeStyle = THEME.shield;
                X.lineWidth = 2;
                X.beginPath(); X.arc(playerX, PLAYER_Y, PLAYER_R + 6 + shields*2, 0, Math.PI*2); X.stroke();
            }
        }
    }

    // Obstacles
    obstacles.forEach(o => {
        X.fillStyle = o.color;
        X.shadowColor = o.color;
        X.shadowBlur = 10;
        X.fillRect(o.x, o.y, o.w, o.h);
        X.shadowBlur = 0;
        // Contrast line
        X.fillStyle = '#fff';
        X.fillRect(o.x, o.y + o.h - 2, o.w, 2);
    });

    // Orbs & Powerups
    orbs.forEach(o => {
        if (o.collected) return;
        X.fillStyle = '#ffd700';
        X.beginPath(); X.arc(o.x, o.y, o.r, 0, Math.PI*2); X.fill();
    });
    powerups.forEach(p => {
        if (p.collected) return;
        X.fillStyle = p.color;
        X.beginPath(); X.arc(p.x, p.y, p.r, 0, Math.PI*2); X.fill();
        X.fillStyle = '#000';
        X.font = '12px sans-serif'; X.textAlign='center';
        X.fillText(p.icon, p.x, p.y+4);
    });

    // Floats
    floats.forEach(f => {
        X.globalAlpha = f.life;
        X.fillStyle = f.color;
        X.font = `${f.size}px "Press Start 2P"`;
        X.textAlign = 'center';
        X.fillText(f.text, f.x, f.y);
    });
    X.globalAlpha = 1;

    // HUD
    X.fillStyle = '#fff';
    X.font = '14px "Press Start 2P"';
    X.textAlign = 'left';
    X.fillText(`SCORE ${score}`, 20, 30);
    X.textAlign = 'right';
    X.fillText(`LVL ${level+1}`, W-20, 30);
    
    if (state === 'menu') {
        X.fillStyle = 'rgba(0,0,0,0.7)';
        X.fillRect(0,0,W,H);
        X.fillStyle = '#fff';
        X.textAlign = 'center';
        X.font = '24px "Press Start 2P"';
        X.fillText('DRIFT', W/2, H/2 - 20);
        X.font = '10px "Press Start 2P"';
        X.fillText('Tap / Click to Start', W/2, H/2 + 20);
    }
    
    if (state === 'dead') {
        X.fillStyle = 'rgba(50,0,0,0.6)';
        X.fillRect(0,0,W,H);
        X.fillStyle = '#fff';
        X.textAlign = 'center';
        X.font = '20px "Press Start 2P"';
        X.fillText('CRASHED', W/2, H/2 - 20);
        X.font = '10px "Press Start 2P"';
        X.fillText(`Score: ${score}`, W/2, H/2 + 10);
        X.fillText('Tap to Retry', W/2, H/2 + 40);
    }

    X.restore();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
