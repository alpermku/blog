<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Entropi Saati - Alex Yalın</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0f; overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100vh; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2;
  cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

class Particle {
  constructor(x, y, hue) {
    this.homeX = x;
    this.homeY = y;
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.hue = hue;
    this.size = 2 + Math.random() * 2;
    this.entropy = 0;
  }

  applyEntropy(amount) {
    this.entropy = amount;
    const angle = Math.random() * Math.PI * 2;
    const force = amount * (2 + Math.random() * 4);
    this.vx += Math.cos(angle) * force;
    this.vy += Math.sin(angle) * force;
  }

  update() {
    // Spring back to home
    const dx = this.homeX - this.x;
    const dy = this.homeY - this.y;
    const spring = 0.02;
    this.vx += dx * spring;
    this.vy += dy * spring;
    this.vx *= 0.92;
    this.vy *= 0.92;
    this.x += this.vx;
    this.y += this.vy;
  }

  draw() {
    const dist = Math.sqrt((this.x - this.homeX) ** 2 + (this.y - this.homeY) ** 2);
    const alpha = Math.min(1, 0.4 + dist * 0.005);
    ctx.fillStyle = `hsla(${this.hue}, 80%, 65%, ${alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

let particles = [];
let lastSecond = -1;
let lastMinute = -1;

function generateStructure() {
  particles = [];
  const now = new Date();
  const h = now.getHours();
  const m = now.getMinutes();
  const s = now.getSeconds();
  const timeStr = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;

  // Clock ring particles
  const rings = 5;
  const baseRadius = Math.min(W, H) * 0.25;
  for (let r = 0; r < rings; r++) {
    const radius = baseRadius + r * 18;
    const count = 60 + r * 20;
    const hue = (200 + r * 30 + h * 5) % 360;
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      particles.push(new Particle(x, y, hue));
    }
  }

  // Hour hand
  const hAngle = ((h % 12) / 12) * Math.PI * 2 - Math.PI / 2 + (m / 60) * (Math.PI / 6);
  for (let i = 0; i < 30; i++) {
    const t = i / 30;
    const x = cx + Math.cos(hAngle) * baseRadius * 0.5 * t;
    const y = cy + Math.sin(hAngle) * baseRadius * 0.5 * t;
    particles.push(new Particle(x, y, 50));
  }

  // Minute hand
  const mAngle = (m / 60) * Math.PI * 2 - Math.PI / 2;
  for (let i = 0; i < 40; i++) {
    const t = i / 40;
    const x = cx + Math.cos(mAngle) * baseRadius * 0.75 * t;
    const y = cy + Math.sin(mAngle) * baseRadius * 0.75 * t;
    particles.push(new Particle(x, y, 180));
  }

  // Second hand
  const sAngle = (s / 60) * Math.PI * 2 - Math.PI / 2;
  for (let i = 0; i < 50; i++) {
    const t = i / 50;
    const x = cx + Math.cos(sAngle) * baseRadius * 0.9 * t;
    const y = cy + Math.sin(sAngle) * baseRadius * 0.9 * t;
    particles.push(new Particle(x, y, 0));
  }

  // Center dot
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r2 = Math.random() * 8;
    particles.push(new Particle(cx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, 40));
  }
}

function tick() {
  const now = new Date();
  const s = now.getSeconds();
  const m = now.getMinutes();

  // Every second: entropy pulse
  if (s !== lastSecond) {
    lastSecond = s;
    const intensity = (s / 60); // grows stronger toward minute end
    particles.forEach(p => p.applyEntropy(intensity * 0.8));
  }

  // Every minute: revolution — rebuild
  if (m !== lastMinute) {
    lastMinute = m;
    generateStructure();
  }
}

function animate() {
  ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
  ctx.fillRect(0, 0, W, H);

  tick();
  particles.forEach(p => { p.update(); p.draw(); });

  // Time text
  const now = new Date();
  const timeStr = now.toLocaleTimeString('tr-TR', { hour12: false });
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.font = `${Math.min(W,H) * 0.04}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(timeStr, cx, cy + Math.min(W,H) * 0.38);

  requestAnimationFrame(animate);
}

generateStructure();
lastMinute = new Date().getMinutes();
lastSecond = new Date().getSeconds();
animate();
</script>
</body>
</html>
