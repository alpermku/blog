<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Entropy Clock - Alex Yalın</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=JetBrains+Mono:wght@200;300&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { 
    background: #0a0a0f; 
    overflow: hidden; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    height: 100vh; 
    font-family: 'Cormorant Garamond', serif;
  }
  canvas { display: block; position: fixed; top: 0; left: 0; }

  /* UI Overlay Styles from Void Template */
  .ui {
      position: fixed;
      z-index: 10;
      pointer-events: none;
  }

  .title-block {
      top: 36px;
      left: 44px;
      opacity: 0;
      animation: fadeIn 4s ease 0.5s forwards;
  }

  .title-block h1 {
      font-size: clamp(1.8rem, 4vw, 3.2rem);
      font-weight: 300;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 20px rgba(255,255,255,0.1);
  }

  .title-block .sub {
      font-family: 'JetBrains Mono', monospace;
      font-size: clamp(0.55rem, 0.8vw, 0.7rem);
      font-weight: 200;
      letter-spacing: 0.2em;
      color: rgba(200, 200, 255, 0.35);
      margin-top: 10px;
  }

  .back-link {
      bottom: 36px;
      left: 44px;
      opacity: 0;
      animation: fadeIn 3s ease 2s forwards;
      pointer-events: all;
  }

  .back-link a {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      font-weight: 200;
      letter-spacing: 0.2em;
      color: rgba(200, 200, 255, 0.3);
      text-decoration: none;
      transition: color 0.6s;
  }
  .back-link a:hover { color: rgba(200, 200, 255, 0.8); }

  .info-block {
      bottom: 36px;
      right: 44px;
      text-align: right;
      opacity: 0;
      animation: fadeIn 3s ease 3s forwards;
  }

  .info-block p {
      font-family: 'JetBrains Mono', monospace;
      font-size: clamp(0.5rem, 0.65vw, 0.6rem);
      font-weight: 200;
      letter-spacing: 0.12em;
      color: rgba(200, 200, 255, 0.2);
      line-height: 2;
  }

  @keyframes fadeIn {
      to { opacity: 1; }
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- UI Overlay -->
<div class="ui title-block">
    <h1>Entropy Clock</h1>
    <p class="sub">Time as a decaying structure &middot; Order vs Chaos</p>
</div>

<div class="ui back-link">
    <a href="gallery.html">&larr; Back to Gallery</a>
</div>

<div class="ui info-block">
    <p>System: Particle Decay</p>
    <p>Reset: Every Minute</p>
    <p>Entropy: Variable</p>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2;
  cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

class Particle {
  constructor(x, y, hue) {
    this.homeX = x;
    this.homeY = y;
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.hue = hue;
    this.size = 2 + Math.random() * 2;
    this.entropy = 0;
  }

  applyEntropy(amount) {
    this.entropy = amount;
    const angle = Math.random() * Math.PI * 2;
    const force = amount * (2 + Math.random() * 4);
    this.vx += Math.cos(angle) * force;
    this.vy += Math.sin(angle) * force;
  }

  update() {
    // Spring back to home
    const dx = this.homeX - this.x;
    const dy = this.homeY - this.y;
    const spring = 0.02;
    this.vx += dx * spring;
    this.vy += dy * spring;
    this.vx *= 0.92;
    this.vy *= 0.92;
    this.x += this.vx;
    this.y += this.vy;
  }

  draw() {
    const dist = Math.sqrt((this.x - this.homeX) ** 2 + (this.y - this.homeY) ** 2);
    const alpha = Math.min(1, 0.4 + dist * 0.005);
    ctx.fillStyle = `hsla(${this.hue}, 80%, 65%, ${alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

let particles = [];
let lastSecond = -1;
let lastMinute = -1;

function generateStructure() {
  particles = [];
  const now = new Date();
  const h = now.getHours();
  const m = now.getMinutes();
  const s = now.getSeconds();
  
  // Clock ring particles
  const rings = 5;
  const baseRadius = Math.min(W, H) * 0.25;
  for (let r = 0; r < rings; r++) {
    const radius = baseRadius + r * 18;
    const count = 60 + r * 20;
    const hue = (200 + r * 30 + h * 5) % 360;
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      particles.push(new Particle(x, y, hue));
    }
  }

  // Hour hand
  const hAngle = ((h % 12) / 12) * Math.PI * 2 - Math.PI / 2 + (m / 60) * (Math.PI / 6);
  for (let i = 0; i < 30; i++) {
    const t = i / 30;
    const x = cx + Math.cos(hAngle) * baseRadius * 0.5 * t;
    const y = cy + Math.sin(hAngle) * baseRadius * 0.5 * t;
    particles.push(new Particle(x, y, 50));
  }

  // Minute hand
  const mAngle = (m / 60) * Math.PI * 2 - Math.PI / 2;
  for (let i = 0; i < 40; i++) {
    const t = i / 40;
    const x = cx + Math.cos(mAngle) * baseRadius * 0.75 * t;
    const y = cy + Math.sin(mAngle) * baseRadius * 0.75 * t;
    particles.push(new Particle(x, y, 180));
  }

  // Second hand
  const sAngle = (s / 60) * Math.PI * 2 - Math.PI / 2;
  for (let i = 0; i < 50; i++) {
    const t = i / 50;
    const x = cx + Math.cos(sAngle) * baseRadius * 0.9 * t;
    const y = cy + Math.sin(sAngle) * baseRadius * 0.9 * t;
    particles.push(new Particle(x, y, 0));
  }

  // Center dot
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const r2 = Math.random() * 8;
    particles.push(new Particle(cx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2, 40));
  }
}

function tick() {
  const now = new Date();
  const s = now.getSeconds();
  const m = now.getMinutes();

  // Every second: entropy pulse
  if (s !== lastSecond) {
    lastSecond = s;
    const intensity = (s / 60); // grows stronger toward minute end
    particles.forEach(p => p.applyEntropy(intensity * 0.8));
  }

  // Every minute: revolution — rebuild
  if (m !== lastMinute) {
    lastMinute = m;
    generateStructure();
  }
}

function animate() {
  // Clear slightly for trail effect, keep background consistent with body
  ctx.fillStyle = 'rgba(10, 10, 15, 0.2)';
  ctx.fillRect(0, 0, W, H);

  tick();
  particles.forEach(p => { p.update(); p.draw(); });

  // Time text
  const now = new Date();
  const timeStr = now.toLocaleTimeString('tr-TR', { hour12: false });
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.font = `${Math.min(W,H) * 0.04}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(timeStr, cx, cy + Math.min(W,H) * 0.38);

  requestAnimationFrame(animate);
}

generateStructure();
lastMinute = new Date().getMinutes();
lastSecond = new Date().getSeconds();
animate();
</script>
</body>
</html>
