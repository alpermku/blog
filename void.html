<!DOCTYPE html> <html lang="tr"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>The Void - Alex Yalın</title> <style> @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=JetBrains+Mono:wght@200;300&display=swap'); * { margin: 0; padding: 0; box-sizing: border-box; } body { background: #000; overflow: hidden; font-family: 'Cormorant Garamond', serif; color: #fff; cursor: crosshair; } canvas#gl { display: block; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; } .ui { position: fixed; z-index: 10; pointer-events: none; } .title-block { top: 36px; left: 44px; opacity: 0; animation: fadeIn 4s ease 0.5s forwards; } .title-block h1 { font-size: clamp(1.8rem, 4vw, 3.2rem); font-weight: 300; letter-spacing: 0.5em; text-transform: uppercase; color: rgba(255, 255, 255, 0.8); } .title-block .sub { font-family: 'JetBrains Mono', monospace; font-size: clamp(0.55rem, 0.8vw, 0.7rem); font-weight: 200; letter-spacing: 0.35em; color: rgba(255, 190, 130, 0.35); margin-top: 10px; } .back-link { bottom: 36px; left: 44px; opacity: 0; animation: fadeIn 3s ease 2s forwards; pointer-events: all; } .back-link a { font-family: 'JetBrains Mono', monospace; font-size: 0.65rem; font-weight: 200; letter-spacing: 0.2em; color: rgba(255, 190, 130, 0.3); text-decoration: none; transition: color 0.6s; } .back-link a:hover { color: rgba(255, 200, 150, 0.8); } .physics-info { bottom: 36px; right: 44px; text-align: right; opacity: 0; animation: fadeIn 3s ease 3s forwards; } .physics-info p { font-family: 'JetBrains Mono', monospace; font-size: clamp(0.5rem, 0.65vw, 0.6rem); font-weight: 200; letter-spacing: 0.12em; color: rgba(255, 190, 130, 0.2); line-height: 2; } .credit { top: 36px; right: 44px; text-align: right; opacity: 0; animation: fadeIn 3s ease 2.5s forwards; } .credit p { font-family: 'JetBrains Mono', monospace; font-size: 0.55rem; font-weight: 200; letter-spacing: 0.15em; color: rgba(255, 190, 130, 0.18); line-height: 1.8; } .credit a { color: rgba(255, 190, 130, 0.25); text-decoration: none; pointer-events: all; transition: color 0.5s; } .credit a:hover { color: rgba(255, 200, 150, 0.6); } @keyframes fadeIn { to { opacity: 1; } } </style> </head> <body> <canvas id="gl"></canvas> <div class="ui title-block"> <h1>The Void</h1> <p class="sub">Gravitational singularity &middot; Event horizon simulation</p> </div> <div class="ui back-link"> <a href="gallery.html">&larr; Back to Gallery</a> </div> <div class="ui credit"> <p>Based on Kip Thorne's equations</p> <p>Kerr metric &middot; DNGR framework</p> <p style="margin-top:4px;"><a href="https://arxiv.org/abs/1502.03808" target="_blank">arXiv:1502.03808</a></p> </div> <div class="ui physics-info"> <p>Spin parameter a/M = 0.6</p> <p>Schwarzschild radius Rs = 2GM/c&sup2;</p> <p>Photon sphere r = 1.5 Rs</p> <p>Accretion disk T ~ 10&#x2077; K</p> </div> <!-- ═══════════════════════════════════════════════════════════ VERTEX SHADER ═══════════════════════════════════════════════════════════ --> <script id="vs" type="x-shader/x-vertex"> attribute vec2 aPosition; varying vec2 vUV; void main() { vUV = aPosition * 0.5 + 0.5;gl_Position = vec4(aPosition, 0.0, 1.0); } </script> <!-- ═══════════════════════════════════════════════════════════ FRAGMENT SHADER: Kerr Black Hole Ray Tracer Based on Kip Thorne & Oliver James (Class. Quantum Grav. 32 065001) Geodesic integration in curved Schwarzschild+spin spacetime ═══════════════════════════════════════════════════════════ --> <script id="fs" type="x-shader/x-fragment"> precision highp float; varying vec2 vUV; uniform float uTime; uniform vec2 uResolution; uniform vec2 uMouse; #define PI 3.14159265359 #define MAX_STEPS 200 // Black hole mass (geometric units G=c=1) const float M = 1.0; const float Rs = 2.0; // Schwarzschild radius const float a = 0.6; // Spin parameter (Kerr) // Event horizon: r+ = M + sqrt(M^2 - a^2) // For a=0.6: r+ = 1.0 + sqrt(1.0 - 0.36) = 1.0 + 0.8 = 1.8 // ── Pseudo-random ── float hash21(vec2 p) { p = fract(p * vec2(123.34, 456.21)); p += dot(p, p + 45.32); return fract(p.x * p.y); } float hash31(vec3 p) { p = fract(p * vec3(0.1031, 0.1030, 0.0973)); p += dot(p, p.yxz + 33.33); return fract((p.x + p.y) * p.z); } // ── Noise for nebula ── float noise(vec3 p) { vec3 i = floor(p); vec3 f = fract(p); f = f * f * (3.0 - 2.0 * f); float a = hash31(i); float b = hash31(i + vec3(1, 0, 0)); float c = hash31(i + vec3(0, 1, 0)); float d = hash31(i + vec3(1, 1, 0)); float e = hash31(i + vec3(0, 0, 1)); float ff = hash31(i + vec3(1, 0, 1)); float g = hash31(i + vec3(0, 1, 1)); float h = hash31(i + vec3(1, 1, 1)); return mix( mix(mix(a, b, f.x), mix(c, d, f.x), f.y), mix(mix(e, ff, f.x), mix(g, h, f.x), f.y), f.z ); } // ── Procedural star field ── vec3 starField(vec3 dir) { vec3 col = vec3(0.0); vec3 absDir = normalize(dir); // Dense star layers for (int layer = 0; layer < 3; layer++) { float scale = 60.0 + float(layer) * 50.0; vec3 cell = floor(absDir * scale); vec3 f = fract(absDir * scale); float h = hash31(cell + float(layer) * 137.0); if (h > 0.96) { float dist = length(f - vec3(0.5)); float star = smoothstep(0.12, 0.0, dist); star *= (0.4 + 0.6 * h); // Color temp float t = hash31(cell + 73.0); vec3 sc = t < 0.3 ? vec3(0.65, 0.75, 1.0) : t < 0.7 ? vec3(1.0, 0.97, 0.93) : vec3(1.0, 0.82, 0.55); float twinkle = 0.75 + 0.25 * sin(uTime * (1.5 + h * 3.0) + h * 50.0); col += sc * star * twinkle; } } // Milky Way band float galacticLat = abs(absDir.y); float milkyWay = smoothstep(0.35, 0.0, galacticLat); float mwNoise = noise(absDir * 8.0) * noise(absDir * 16.0 + 5.0); col += vec3(0.025, 0.015, 0.035) * milkyWay * mwNoise * 3.0; // Subtle nebula patches float neb1 = noise(absDir * 3.0 + vec3(0.0, 0.0, uTime * 0.01)); float neb2 = noise(absDir * 5.0 + vec3(10.0)); col += vec3(0.015, 0.005, 0.025) * smoothstep(0.5, 0.8, neb1) * neb2; col += vec3(0.005, 0.012, 0.02) * smoothstep(0.55, 0.85, neb2) * neb1; return col; } // ── Accretion disk emission ── vec3 accretionDisk(float r, float phi) { float rInner = 3.0; // ~ISCO float rOuter = 14.0; if (r < rInner || r > rOuter) return vec3(0.0); float frac_r = (r - rInner) / (rOuter - rInner); // Blackbody temperature profile: T ~ r^(-3/4) float temp = pow(max(0.01, 1.0 - frac_r), 0.75); // ── Doppler beaming (Kip Thorne's critical effect) ── // In the film they removed this; in the paper it's there // Keplerian orbital velocityfloat omega = 1.0 / (pow(r, 1.5) + a); float v_orbital = r * omega; // Velocity component toward observer float v_los = v_orbital * (-sin(phi)) * 0.45; // Relativistic Doppler factor float gamma = 1.0 / sqrt(max(0.01, 1.0 - v_los * v_los)); float doppler = gamma * (1.0 + v_los); float beaming = doppler * doppler * doppler; // D^3 for intensity // ── Disk structure ── // Turbulent spiral arms float spiral1 = sin(phi * 3.0 - log(r + 1.0) * 5.0 + uTime * 0.4) * 0.5 + 0.5; float spiral2 = sin(phi * 5.0 + log(r + 1.0) * 3.0 - uTime * 0.25) * 0.5 + 0.5; float turb = noise(vec3(cos(phi) * r * 0.3, sin(phi) * r * 0.3, uTime * 0.15)); float density = 0.5 + 0.3 * spiral1 + 0.2 * spiral2; density *= (0.7 + 0.3 * turb); // Hot spots float hotspot = smoothstep(0.75, 1.0, noise(vec3(phi * 2.0 + uTime * 0.3, r * 0.5, uTime * 0.1))); density += hotspot * 0.4; // ── Blackbody color ── vec3 color; if (frac_r < 0.15) { // Inner edge: brilliant white-blue (extremely hot) color = mix(vec3(0.9, 0.92, 1.0), vec3(1.0, 0.9, 0.7), frac_r / 0.15); } else if (frac_r < 0.4) { // Mid-inner: golden-white color = mix(vec3(1.0, 0.9, 0.7), vec3(1.0, 0.65, 0.25), (frac_r - 0.15) / 0.25); } else if (frac_r < 0.7) { // Middle: orange color = mix(vec3(1.0, 0.65, 0.25), vec3(0.85, 0.3, 0.05), (frac_r - 0.4) / 0.3); } else { // Outer: deep red, fading color = mix(vec3(0.85, 0.3, 0.05), vec3(0.3, 0.05, 0.01), (frac_r - 0.7) / 0.3); } // Apply Doppler color shift float dShift = clamp((beaming - 1.0) * 0.15, -0.3, 0.3); color = mix(color, color * vec3(0.85, 0.9, 1.15), max(0.0, dShift)); color = mix(color, color * vec3(1.2, 0.8, 0.6), max(0.0, -dShift)); // Gravitational redshift float gRedshift = sqrt(max(0.01, 1.0 - Rs / r)); float intensity = temp * density * clamp(beaming, 0.15, 5.0) * gRedshift; // Edge softness float edgeFade = smoothstep(0.0, 0.08, frac_r) * smoothstep(1.0, 0.85, frac_r); return color * intensity * edgeFade * 2.5; } // ═══════════════════════════════════════════════════════ // MAIN: Geodesic ray tracing through Schwarzschild metric // with Kerr spin corrections (Lense-Thirring drag) // ═══════════════════════════════════════════════════════ void main() { vec2 uv = (gl_FragCoord.xy - uResolution * 0.5) / min(uResolution.x, uResolution.y); // ── Camera ── float camDist = 28.0; float yawOffset = (uMouse.x - 0.5) * 0.4; float pitchOffset = (uMouse.y - 0.5) * 0.25; float pitch = 0.32 + pitchOffset; // slight above-equator view vec3 camPos = camDist * vec3( sin(yawOffset) * cos(pitch), sin(pitch), cos(yawOffset) * cos(pitch) ); vec3 fwd = normalize(-camPos); vec3 worldUp = vec3(0.0, 1.0, 0.0); vec3 right = normalize(cross(fwd, worldUp)); vec3 up = cross(right, fwd); float fov = 0.9; vec3 rd = normalize(fwd + (uv.x * right + uv.y * up) * fov); // ═══ RAY INTEGRATION ═══ vec3 pos = camPos; vec3 vel = rd * 1.0; // light speed = 1 vec3 totalDiskColor = vec3(0.0); float totalDiskAlpha = 0.0; float prevY = pos.y; bool escaped = false; bool captured = false; // Event horizon radius for Kerr float rH = 1.0 + sqrt(1.0 - a * a); for (int step = 0; step < MAX_STEPS; step++) { float r = length(pos); // Captured by black hole if (r < rH * 1.02) { captured = true; break; } // Escaped if (r > 55.0) { escaped = true; break; } // ── Geodesic equation in Schwarzschild+Kerr ── // Gravitational acceleration on photon: // The key physics: in GR, light is deflected by // d²x/dλ² = -(Schwarzschild potential gradient) // with a correction term ~L²/r³ that creates the photon sphere float r2 = r * r; float r3 = r2 * r; vec3 rhat = pos / r; // Effective force: -dV/dr where V(r) includes centrifugal barrier // For null geodesics: F = -Rs/(2r²) * [1 + 3*(L/r)²] // L (angular momentum per unit mass) relates to impact parameter vec3 crossRV = cross(pos, vel); float L2 = dot(crossRV, crossRV); // Radial acceleration (Schwarzschild) float fRadial = -Rs / (2.0 * r2); // GR correction: this creates the photon sphere at r=1.5Rs // and the strong lensing near the black hole float grCorrection = -3.0 * Rs * L2 / (2.0 * r2 * r2); vec3 accel = rhat * (fRadial + grCorrection); // Kerr frame-dragging (Lense-Thirring effect) // Drags photons in direction of BH spin vec3 spinDir = vec3(0.0, 1.0, 0.0); vec3 dragForce = cross(spinDir, vel) * (2.0 * a * M * Rs / (r3 + 0.01)) * 0.25; accel += dragForce; // Adaptive timestep float dt = 0.12 + 0.2 * smoothstep(4.0, 25.0, r); // Velocity Verlet integration vec3 newVel = vel + accel * dt; vec3 newPos = pos + newVel * dt; // ── Disk intersection check ── // Detect equatorial plane crossing (y sign change) if (prevY * newPos.y <= 0.0) { // Linear interpolation to find crossing point float t_cross = abs(prevY) / (abs(prevY) + abs(newPos.y) + 0.0001); vec3 crossP = mix(pos, newPos, t_cross); float crossR = length(vec2(crossP.x, crossP.z)); float crossPhi = atan(crossP.x, crossP.z); vec3 diskC = accretionDisk(crossR, crossPhi); if (dot(diskC, diskC) > 0.0001) { float alpha = clamp(length(diskC) * 0.6, 0.0, 0.97); // Additive blending - light from multiple disk crossings // (gravitational lensing wraps light over and under the BH) totalDiskColor += diskC * (1.0 - totalDiskAlpha); totalDiskAlpha = totalDiskAlpha + alpha * (1.0 - totalDiskAlpha); } } prevY = newPos.y; pos = newPos; vel = newVel; } // ── Compose final color ── vec3 color = vec3(0.0); if (captured) { // Black hole shadow - absolute black // Any disk light gathered before capture still shows color = totalDiskColor; } else { // Ray escaped: background stars (already lensed by integration) vec3 finalDir = normalize(vel); vec3 bg = starField(finalDir); // Composite disk over background color = mix(bg, totalDiskColor, totalDiskAlpha); // Add disk emission (it's emissive, not just occluding) color += totalDiskColor * (1.0 - totalDiskAlpha) * 0.3; } // ── Photon ring enhancement ── // Near-miss rays that graze the photon sphere // accumulate incredible brightness - this happens naturally // from our ray tracer when rays nearly orbit // ── Warm ambient glow from disk illumination ── float centerDist = length(uv); float ambientGlow = exp(-centerDist * 2.5) * 0.04; color += vec3(1.0, 0.65, 0.25) * ambientGlow; // ── Vignette ── float vig = 1.0 - smoothstep(0.5, 1.3, centerDist); color *= mix(0.4, 1.0, vig); // ── Filmic tone mapping (ACES approximation) ── color *= 1.2; vec3 x = color; color = (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14); // ── Film grain ── float grain = (hash21(gl_FragCoord.xy * 0.5 + fract(uTime * 7.0)) - 0.5) * 0.025; color += grain; // ── Gamma ── color = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2)); gl_FragColor = vec4(color, 1.0); } </script> <!-- ═══════════════════════════════════════════════════════════ JavaScript: WebGL Setup & Render Loop ═══════════════════════════════════════════════════════════ --> <script> const canvas = document.getElementById('gl'); const gl = canvas.getContext('webgl', { antialias: false, alpha: false, preserveDrawingBuffer: false, powerPreference: 'high-performance' }); if (!gl) { document.body.innerHTML = '<p style="color:#aaa;padding:50px;font-family:monospace;">WebGL gerekli. Lütfen modern bir tarayıcı kullanın.</p>'; throw new Error('WebGL unavailable'); } // Compile shader function makeShader(type, id) { const shader = gl.createShader(type); gl.shaderSource(shader, document.getElementById(id).textContent); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)); return null; } return shader; } const vertShader = makeShader(gl.VERTEX_SHADER, 'vs'); const fragShader = makeShader(gl.FRAGMENT_SHADER, 'fs'); const program = gl.createProgram(); gl.attachShader(program, vertShader); gl.attachShader(program, fragShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(program)); } // Fullscreen quad const verts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]); const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW); const aPos = gl.getAttribLocation(program, 'aPosition'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0); gl.useProgram(program); const uTime = gl.getUniformLocation(program, 'uTime'); const uRes = gl.getUniformLocation(program, 'uResolution'); const uMouse = gl.getUniformLocation(program, 'uMouse'); // ── State ── let mx = 0.5, my = 0.5; let smx = 0.5, smy = 0.5; let time = 0; let lastT = performance.now(); function resize() { // Reduce resolution for performance (ray tracing is expensive) const scale = Math.min(window.devicePixelRatio || 1, 1.25); canvas.width = Math.floor(window.innerWidth * scale); canvas.height = Math.floor(window.innerHeight * scale); gl.viewport(0, 0, canvas.width, canvas.height); } function frame(now) { const dt = Math.min((now - lastT) / 1000, 0.05); lastT = now; time += dt; // Smooth mouse with inertia smx += (mx - smx) * 0.025; smy += (my - smy) * 0.025; gl.uniform1f(uTime, time); gl.uniform2f(uRes, canvas.width, canvas.height); gl.uniform2f(uMouse, smx, smy); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); requestAnimationFrame(frame); } // ── Events ── window.addEventListener('resize', resize); document.addEventListener('mousemove', e => { mx = e.clientX / window.innerWidth; my = 1.0 - e.clientY / window.innerHeight; }); document.addEventListener('touchmove', e => { e.preventDefault(); mx = e.touches[0].clientX / window.innerWidth; my = 1.0 - e.touches[0].clientY / window.innerHeight; }, { passive: false }); // ── Launch ── resize(); requestAnimationFrame(frame); </script> </body> </html>