<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kerr Black Hole - Alex Yalın</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/jpeg" href="assets/avatar.jpg">
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; color: #eee; }
        canvas { display: block; width: 100%; height: 100%; }
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .overlay h1 {
            font-family: 'Inter', sans-serif;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,200,50,0.3);
        }
        .overlay p {
            font-family: 'Lora', serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin: 5px 0 0 0;
        }
        .back-link {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.3s;
            pointer-events: auto;
        }
        .back-link:hover {
            color: #fff;
            border-bottom-color: #fff;
        }
    </style>
</head>
<body>
    <div class="overlay">
        <h1>Kerr Black Hole</h1>
        <p>General Relativity. Frame dragging. Photon rings.</p>
    </div>
    
    <a href="gallery.html" class="back-link">&larr; Back to Gallery</a>

    <canvas id="glCanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;

        // Constants
        #define MAX_STEPS 100
        #define M 1.0         // Mass
        #define Rs (2.0 * M)  // Schwarzschild Radius
        #define a 0.9         // Spin parameter (0 to 1)

        // ── Helper Functions ──
        
        // Hash for stars
        float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }

        // Procedural Starfield
        vec3 starField(vec3 dir) {
            vec2 uv = dir.xy / (abs(dir.z) + 0.001); // Simple projection
            float n = hash(floor(uv * 400.0));
            float star = step(0.998, n) * n; // Sparse stars
            // Twinkle
            float twinkle = 0.5 + 0.5 * sin(iTime * 2.0 + n * 100.0);
            return vec3(star * twinkle);
        }

        // Procedural Accretion Disk Texture
        vec3 accretionDisk(float r, float phi) {
            // Disk range: 3M to 12M
            if (r < 2.5 * M || r > 12.0 * M) return vec3(0.0);
            
            // Rotating texture
            float rot = phi + iTime * (sqrt(M/(r*r*r))); // Keplerian speed
            
            // Noise pattern (rings + turbulence)
            float noise = sin(r * 10.0 + rot * 2.0) * 0.5 + 0.5;
            noise *= sin(r * 20.0 - rot * 5.0) * 0.5 + 0.5;
            
            // Color mapping (Blackbody-ish: Hot center -> Cold edge)
            float temp = 1.0 - (r - 2.5 * M) / (9.5 * M); // 1.0 at inner, 0.0 at outer
            temp = pow(temp, 0.5); // Gamma correction
            
            vec3 color = vec3(1.0, 0.5 * temp, 0.1 * temp * temp) * temp * 2.0;
            color *= (0.5 + 0.5 * noise); // Apply texture
            
            // Soft edges
            float edge = smoothstep(2.5*M, 3.0*M, r) * smoothstep(12.0*M, 10.0*M, r);
            return color * edge;
        }

        // ── Main Tracer ──
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
            vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
            
            // Camera setup
            float camDist = 18.0;
            float camElev = 0.2 + (iMouse.y / iResolution.y - 0.5) * 2.0; // Interactive pitch
            float camAzim = iTime * 0.1 + (iMouse.x / iResolution.x) * 6.0; // Rotate + Interactive yaw
            
            vec3 ro = vec3(camDist * cos(camElev) * sin(camAzim), 
                           camDist * sin(camElev), 
                           camDist * cos(camElev) * cos(camAzim));
            
            vec3 target = vec3(0.0);
            vec3 fwd = normalize(target - ro);
            vec3 right = normalize(cross(vec3(0,1,0), fwd));
            vec3 up = cross(fwd, right);
            vec3 rd = normalize(fwd + right * uv.x + up * uv.y);

            // State
            vec3 pos = ro;
            vec3 vel = rd; // Light travels at c=1
            
            vec3 totalDiskColor = vec3(0.0);
            float totalDiskAlpha = 0.0;
            bool captured = false;
            float prevY = pos.y;

            // ── Ray Integration (The User's Code Logic) ──
            for(int i=0; i<MAX_STEPS; i++) {
                float r = length(pos);
                
                // Event Horizon check
                if (r < (Rs * 1.05)) { // Slightly above horizon to catch capture
                    captured = true;
                    break;
                }
                // Escape check
                if (r > 30.0) break;

                // ── Geodesic Equation ──
                float r2 = r * r;
                float r3 = r2 * r;
                vec3 rhat = pos / r;
                
                vec3 crossRV = cross(pos, vel);
                float L2 = dot(crossRV, crossRV); // Angular momentum squared
                
                // Forces
                float fRadial = -Rs / (2.0 * r2);
                float grCorrection = -3.0 * Rs * L2 / (2.0 * r2 * r2);
                vec3 accel = rhat * (fRadial + grCorrection);
                
                // Kerr Spin (Frame Dragging)
                vec3 spinDir = vec3(0.0, 1.0, 0.0);
                vec3 dragForce = cross(spinDir, vel) * (2.0 * a * M * Rs / (r3 + 0.01)) * 0.25;
                accel += dragForce;

                // Adaptive Timestep
                float dt = 0.05 + 0.1 * smoothstep(2.0 * M, 10.0 * M, r); // Finer steps near BH

                // Verlet
                vec3 newVel = vel + accel * dt;
                vec3 newPos = pos + newVel * dt;

                // ── Disk Intersection ──
                if (prevY * newPos.y <= 0.0) { // Crossed equator
                    float t_cross = abs(prevY) / (abs(prevY) + abs(newPos.y) + 0.0001);
                    vec3 crossP = mix(pos, newPos, t_cross);
                    float crossR = length(vec2(crossP.x, crossP.z));
                    
                    if (crossR > 2.5 * M && crossR < 12.0 * M) { // Simple bounds check first
                        float crossPhi = atan(crossP.x, crossP.z);
                        vec3 diskC = accretionDisk(crossR, crossPhi);
                        
                        // Accumulate light (Semi-transparent disk)
                        float alpha = clamp(length(diskC) * 0.8, 0.0, 0.8);
                        totalDiskColor += diskC * (1.0 - totalDiskAlpha);
                        totalDiskAlpha += alpha;
                        if (totalDiskAlpha > 0.98) break; // Opaque enough
                    }
                }

                prevY = newPos.y;
                pos = newPos;
                vel = newVel;
            }

            // ── Composition ──
            vec3 color = vec3(0.0);
            
            if (captured) {
                // Black hole shadow
                color = totalDiskColor; 
            } else {
                // Background stars
                vec3 finalDir = normalize(vel);
                vec3 bg = starField(finalDir);
                color = mix(bg, totalDiskColor, totalDiskAlpha);
                
                // Glow around shadow
                color += totalDiskColor * 0.2; 
            }

            // ACES Tone Mapping
            color *= 1.2;
            vec3 x = color;
            color = (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);
            
            // Gamma
            color = pow(color, vec3(1.0/2.2));

            fragColor = vec4(color, 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert("WebGL not supported"); }

        // Setup Geometry (Quad)
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Compile Shaders
        const vsSource = document.getElementById('vertex-shader').text;
        const fsSource = document.getElementById('fragment-shader').text;

        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fsSource);
        gl.compileShader(fs);
        
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(fs));
        }

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Attributes & Uniforms
        const positionLocation = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uResolution = gl.getUniformLocation(program, "iResolution");
        const uTime = gl.getUniformLocation(program, "iTime");
        const uMouse = gl.getUniformLocation(program, "iMouse");

        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY; // WebGL coordinates are usually Y-up, but here we pass raw
        });

        // Loop
        function render(time) {
            time *= 0.001; // Seconds

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.uniform2f(uResolution, canvas.width, canvas.height);
            gl.uniform1f(uTime, time);
            gl.uniform2f(uMouse, mouseX, canvas.height - mouseY); // Flip Y for shader

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>