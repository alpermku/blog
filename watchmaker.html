<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Blind Watchmaker - Alex Yalın</title>
    <link rel="icon" type="image/jpeg" href="assets/avatar.jpg">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=JetBrains+Mono:wght@300;400&family=Syne:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
        body,html{overflow:hidden;background:#04080d;color:#eee;font-family:'JetBrains Mono',monospace;height:100%;width:100%}
        canvas{display:block;position:absolute;top:0;left:0;cursor:crosshair}
        .overlay-top{position:absolute;top:24px;left:28px;pointer-events:none;z-index:10}
        .overlay-top h1{font-family:'Syne',sans-serif;font-size:1.3rem;font-weight:700;color:rgba(255,255,255,.9);text-transform:uppercase;letter-spacing:4px;text-shadow:0 0 30px rgba(80,220,140,.2)}
        .overlay-top .subtitle{font-family:'Cormorant Garamond',serif;font-size:.9rem;font-weight:300;font-style:italic;color:rgba(255,255,255,.35);margin:5px 0 0 2px}
        .overlay-top .tagline{font-size:.55rem;font-weight:300;color:rgba(255,255,255,.18);margin:12px 0 0 2px;letter-spacing:1.5px;text-transform:uppercase}
        .stats-panel{position:absolute;top:24px;right:28px;z-index:10;pointer-events:none;text-align:right}
        .stat-row{font-size:.6rem;font-weight:300;color:rgba(255,255,255,.22);letter-spacing:1px;text-transform:uppercase;margin-bottom:3px}
        .stat-value{color:rgba(255,255,255,.5);font-weight:400}
        .controls-hint{position:absolute;bottom:24px;right:28px;z-index:10;pointer-events:none;text-align:right;opacity:.2}
        .hint-line{font-size:.55rem;font-weight:300;color:rgba(255,255,255,.5);letter-spacing:1px;margin-bottom:2px}
        .hint-key{color:rgba(80,220,140,.6);font-weight:400}
        .back-link{position:absolute;bottom:24px;left:28px;font-size:.6rem;font-weight:300;color:rgba(255,255,255,.22);text-decoration:none;letter-spacing:1.5px;text-transform:uppercase;transition:all .4s;z-index:10}
        .back-link:hover{color:rgba(255,255,255,.7);letter-spacing:2.5px}
        .flash-overlay{position:fixed;inset:0;background:radial-gradient(circle at var(--fx,50%) var(--fy,50%),rgba(80,220,140,.07),transparent 55%);pointer-events:none;z-index:5;opacity:0;transition:opacity .15s}
        .flash-overlay.active{opacity:1;transition:opacity .05s}
        .hover-label{position:absolute;pointer-events:none;z-index:15;font-size:.5rem;font-weight:300;letter-spacing:1.2px;text-transform:uppercase;color:rgba(255,255,255,.65);background:rgba(4,8,13,.85);padding:4px 9px;border:1px solid rgba(255,255,255,.06);border-radius:2px;opacity:0;transition:opacity .2s;white-space:nowrap;backdrop-filter:blur(4px)}
        .hover-label.visible{opacity:1}
        .mode-ind{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Syne',sans-serif;font-size:.6rem;font-weight:600;letter-spacing:3px;text-transform:uppercase;color:rgba(80,220,140,.5);pointer-events:none;z-index:15;opacity:0}
        .mode-ind.vis{opacity:1;animation:mp 1.5s ease-out forwards}
        @keyframes mp{0%{opacity:0;transform:translate(-50%,-50%) scale(.9)}20%{opacity:1;transform:translate(-50%,-50%) scale(1)}100%{opacity:0;transform:translate(-50%,-50%) scale(1.05)}}
        .gene-display{position:absolute;bottom:60px;left:28px;z-index:10;pointer-events:none}
        .gene-bars{display:flex;gap:2px;align-items:flex-end;height:28px;margin-bottom:3px}
        .gene-bar{width:3px;border-radius:1px;transition:height .5s cubic-bezier(.22,1,.36,1);min-height:2px}
        .gene-label{font-size:.45rem;color:rgba(255,255,255,.12);letter-spacing:1px;text-transform:uppercase}
    </style>
</head>
<body>
    <div class="overlay-top">
        <h1>The Blind Watchmaker</h1>
        <p class="subtitle">Evolution without design — forms emerging from blind mutation</p>
        <p class="tagline">After Richard Dawkins, 1986</p>
    </div>
    <div class="stats-panel">
        <div class="stat-row">Generation <span class="stat-value" id="gen">0</span></div>
        <div class="stat-row">Mutation <span class="stat-value" id="mutRate">12%</span></div>
        <div class="stat-row">Genes <span class="stat-value" id="geneCount">20</span></div>
        <div class="stat-row">Mode <span class="stat-value" id="modeDisp">Auto-drift</span></div>
    </div>
    <div class="controls-hint">
        <div class="hint-line"><span class="hint-key">Click</span> select survivor</div>
        <div class="hint-line"><span class="hint-key">Space</span> toggle auto</div>
        <div class="hint-line"><span class="hint-key">R</span> reset</div>
        <div class="hint-line"><span class="hint-key">↑↓</span> mutation rate</div>
    </div>
    <div class="gene-display"><div class="gene-bars" id="geneBars"></div><div class="gene-label">Genome</div></div>
    <a href="gallery.html" class="back-link">← Back to Gallery</a>
    <div class="flash-overlay" id="flash"></div>
    <div class="hover-label" id="hoverLabel"></div>
    <div class="mode-ind" id="modeInd"></div>
    <canvas id="c"></canvas>

<script>
(() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const flash = document.getElementById('flash');
    const hoverLabel = document.getElementById('hoverLabel');
    const modeInd = document.getElementById('modeInd');

    let W, H, generation = 0, autoMode = true, mutRate = 0.12;
    let hoveredIdx = -1, time = 0, autoTimer = 0;
    const AUTO_INTERVAL = 260;

    /*
     * GENOME: 20 genes controlling a rich morphospace
     * [0]  numSegments  1-7      body segments
     * [1]  segmentLen   8-50     segment length
     * [2]  spineAngle   -0.8,0.8 spine curvature
     * [3]  spineTaper   0.3,1.2  segment scaling
     * [4]  symmetry     0-2      0=none,1=bilateral,2=radial
     * [5]  radialCount  2-8      radial copies
     * [6]  limbLen      5-45     appendage length
     * [7]  limbAngle    -PI,PI   appendage direction
     * [8]  limbCurve    -1,1     limb curvature
     * [9]  limbsPerSeg  0-4      appendages per segment
     * [10] bodyWidth    2-30     body width
     * [11] bodyShape    0-3      line/ellipse/rect/diamond
     * [12] headSize     0-25     terminal size
     * [13] headShape    0-3      circle/triangle/star/crescent
     * [14] eyeSize      0-10     decoration dots
     * [15] eyeOffset    2-20     eye separation
     * [16] hue          0-360    base color
     * [17] hueShift     -60,60   color shift along body
     * [18] filled       0-1      filled vs outline
     * [19] detail       0-5      extra decorations
     */

    const GENE_DEFS = [
        ['Segments',1,7,true],['SegLen',8,50,false],['SpineAng',-0.8,0.8,false],
        ['Taper',0.3,1.2,false],['Symmetry',0,2,true],['RadialN',2,8,true],
        ['LimbLen',5,45,false],['LimbAng',-Math.PI,Math.PI,false],['LimbCurve',-1,1,false],
        ['LimbsPerSeg',0,4,true],['BodyWidth',2,30,false],['BodyShape',0,3,true],
        ['HeadSize',0,25,false],['HeadShape',0,3,true],['EyeSize',0,10,false],
        ['EyeOffset',2,20,false],['Hue',0,360,false],['HueShift',-60,60,false],
        ['Filled',0,1,true],['Detail',0,5,false]
    ];
    const NG = GENE_DEFS.length;

    let parentGenes = [3,25,0.0,0.85,1,4,20,1.2,0.3,2,10,1,12,0,4,8,180,15,1,2];
    let biomorphs = [], particles = [];

    function clamp(i,v){const d=GENE_DEFS[i];let r=Math.max(d[1],Math.min(d[2],v));if(d[3])r=Math.round(r);return r;}

    function mutate(genes){
        const g=[...genes];
        const n=Math.random()<mutRate?(Math.random()<0.3?3:2):1;
        for(let m=0;m<n;m++){
            const i=Math.floor(Math.random()*NG);
            const d=GENE_DEFS[i];
            if(d[3])g[i]=clamp(i,g[i]+(Math.random()>0.5?1:-1));
            else g[i]=clamp(i,g[i]+(Math.random()-0.5)*(d[2]-d[1])*0.25);
        }
        return g;
    }

    function init(){
        W=canvas.width=window.innerWidth;
        H=canvas.height=window.innerHeight;
        spawnGeneration();
    }

    function spawnGeneration(){
        biomorphs=[];
        const cx=W/2,cy=H/2;
        biomorphs.push({genes:[...parentGenes],x:cx,y:cy,scale:1.5,label:'Parent',alpha:0});
        const rx=Math.min(W,H)*0.32,ry=Math.min(W,H)*0.28;
        for(let i=0;i<8;i++){
            const a=(i/8)*Math.PI*2-Math.PI/2;
            biomorphs.push({genes:mutate(parentGenes),x:cx+Math.cos(a)*rx,y:cy+Math.sin(a)*ry,scale:0.75,label:`Mutant ${i+1}`,alpha:0});
        }
        document.getElementById('gen').innerText=generation;
        document.getElementById('geneCount').innerText=NG;
        updateBars();
    }

    function updateBars(){
        const c=document.getElementById('geneBars');c.innerHTML='';
        parentGenes.forEach((v,i)=>{
            const d=GENE_DEFS[i],norm=(v-d[1])/(d[2]-d[1]);
            const bar=document.createElement('div');bar.className='gene-bar';
            bar.style.height=(2+norm*26)+'px';
            bar.style.background=`hsla(${140+i*10},55%,50%,.45)`;
            c.appendChild(bar);
        });
    }

    // ================================================================
    // DRAWING ENGINE
    // ================================================================
    function drawBiomorph(b,highlight){
        const g=b.genes;
        const numSeg=Math.floor(g[0]),segLen=g[1],spineAng=g[2],taper=g[3];
        const symType=Math.floor(g[4]),radialN=Math.floor(g[5]);
        const limbLen=g[6],limbAng=g[7],limbCurve=g[8],limbsPer=Math.floor(g[9]);
        const bodyW=g[10],bodyShape=Math.floor(g[11]);
        const headSize=g[12],headShape=Math.floor(g[13]);
        const eyeSize=g[14],eyeOff=g[15];
        const hue=g[16],hueShift=g[17],filled=Math.floor(g[18]),detail=g[19];

        ctx.save();
        ctx.translate(b.x,b.y);
        ctx.scale(b.scale,b.scale);
        ctx.globalAlpha=b.alpha;

        if(highlight){ctx.shadowColor=`hsla(${hue},80%,60%,.5)`;ctx.shadowBlur=20;}
        else{ctx.shadowColor=`hsla(${hue},60%,50%,.15)`;ctx.shadowBlur=8;}

        const al=highlight?0.9:0.7;
        const copies=symType===2?radialN:1;
        const mirror=symType===1;

        for(let copy=0;copy<copies;copy++){
            ctx.save();
            if(symType===2)ctx.rotate((copy/copies)*Math.PI*2);
            drawArm(numSeg,segLen,spineAng,taper,limbLen,limbAng,limbCurve,limbsPer,bodyW,bodyShape,headSize,headShape,eyeSize,eyeOff,hue,hueShift,filled,detail,al,highlight);
            if(mirror){ctx.save();ctx.scale(-1,1);drawArm(numSeg,segLen,spineAng,taper,limbLen,limbAng,limbCurve,limbsPer,bodyW,bodyShape,headSize,headShape,eyeSize,eyeOff,hue,hueShift,filled,detail,al,highlight);ctx.restore();}
            ctx.restore();
        }
        ctx.restore();
    }

    function drawArm(numSeg,segLen,spineAng,taper,limbLen,limbAng,limbCurve,limbsPer,bodyW,bodyShape,headSize,headShape,eyeSize,eyeOff,hue,hueShift,filled,detail,alpha,highlight){
        let px=0,py=0,dir=-Math.PI/2,cLen=segLen,cW=bodyW;

        for(let s=0;s<numSeg;s++){
            const segHue=(hue+hueShift*(s/Math.max(1,numSeg)))%360;
            const sat=55+(highlight?20:0),light=45+(highlight?10:0);
            const nx=px+Math.cos(dir)*cLen,ny=py+Math.sin(dir)*cLen;

            ctx.strokeStyle=`hsla(${segHue},${sat}%,${light}%,${alpha})`;
            ctx.fillStyle=`hsla(${segHue},${sat-10}%,${light-10}%,${alpha*0.4})`;
            ctx.lineWidth=Math.max(0.5,1.5*(1-s/(numSeg+1)));

            drawSegShape(px,py,nx,ny,cW,bodyShape,filled);

            if(limbsPer>0){
                for(let li=0;li<limbsPer;li++){
                    const t=limbsPer===1?0.5:li/(limbsPer-1);
                    const lx=px+(nx-px)*t,ly=py+(ny-py)*t;
                    const ba=dir+limbAng+(li-(limbsPer-1)/2)*0.3;
                    ctx.strokeStyle=`hsla(${(segHue+30)%360},${sat}%,${light+5}%,${alpha*0.7})`;
                    ctx.lineWidth=Math.max(0.3,1*(1-s/(numSeg+1)));
                    drawLimb(lx,ly,ba,limbLen*(1-s*0.08),limbCurve);
                }
            }

            if(detail>1){
                const mx=(px+nx)/2,my=(py+ny)/2;
                ctx.fillStyle=`hsla(${(segHue+60)%360},50%,60%,${alpha*0.3})`;
                for(let dd=0;dd<Math.floor(detail);dd++){
                    const da=(dd/detail)*Math.PI*2,dr=cW*0.4;
                    ctx.beginPath();ctx.arc(mx+Math.cos(da)*dr,my+Math.sin(da)*dr,detail*0.5,0,Math.PI*2);ctx.fill();
                }
            }

            px=nx;py=ny;dir+=spineAng;cLen*=taper;cW*=taper;
        }

        // Head
        if(headSize>2){
            const hh=(hue+hueShift)%360;
            ctx.strokeStyle=`hsla(${hh},60%,55%,${alpha})`;
            ctx.fillStyle=`hsla(${hh},50%,45%,${alpha*0.5})`;
            ctx.lineWidth=1;
            drawHead(px,py,dir,headSize,headShape,filled);

            if(eyeSize>1){
                const perpX=Math.cos(dir+Math.PI/2),perpY=Math.sin(dir+Math.PI/2);
                const fX=Math.cos(dir)*headSize*0.3,fY=Math.sin(dir)*headSize*0.3;
                ctx.fillStyle=`hsla(0,0%,95%,${alpha*0.8})`;
                ctx.beginPath();ctx.arc(px+fX+perpX*eyeOff*0.5,py+fY+perpY*eyeOff*0.5,eyeSize*0.5,0,Math.PI*2);ctx.fill();
                ctx.fillStyle=`hsla(${hh},80%,15%,${alpha})`;
                ctx.beginPath();ctx.arc(px+fX+perpX*eyeOff*0.5,py+fY+perpY*eyeOff*0.5,eyeSize*0.2,0,Math.PI*2);ctx.fill();
            }
        }
    }

    function drawSegShape(x1,y1,x2,y2,w,shape,filled){
        const mx=(x1+x2)/2,my=(y1+y2)/2;
        const len=Math.hypot(x2-x1,y2-y1),angle=Math.atan2(y2-y1,x2-x1);
        ctx.save();ctx.translate(mx,my);ctx.rotate(angle);ctx.beginPath();
        switch(shape){
            case 0:ctx.moveTo(-len/2,0);ctx.lineTo(len/2,0);ctx.stroke();break;
            case 1:ctx.ellipse(0,0,len/2,w/2,0,0,Math.PI*2);if(filled)ctx.fill();ctx.stroke();break;
            case 2:ctx.rect(-len/2,-w/2,len,w);if(filled)ctx.fill();ctx.stroke();break;
            case 3:ctx.moveTo(-len/2,0);ctx.lineTo(0,-w/2);ctx.lineTo(len/2,0);ctx.lineTo(0,w/2);ctx.closePath();if(filled)ctx.fill();ctx.stroke();break;
        }
        ctx.restore();
    }

    function drawLimb(x,y,angle,len,curve){
        const cpx=x+Math.cos(angle+curve*0.5)*len*0.5;
        const cpy=y+Math.sin(angle+curve*0.5)*len*0.5;
        const ex=x+Math.cos(angle+curve)*len;
        const ey=y+Math.sin(angle+curve)*len;
        ctx.beginPath();ctx.moveTo(x,y);ctx.quadraticCurveTo(cpx,cpy,ex,ey);ctx.stroke();
        ctx.beginPath();ctx.arc(ex,ey,1.2,0,Math.PI*2);ctx.fill();
    }

    function drawHead(x,y,dir,size,shape,filled){
        ctx.save();ctx.translate(x,y);ctx.rotate(dir);ctx.beginPath();
        switch(shape){
            case 0:ctx.arc(0,0,size/2,0,Math.PI*2);break;
            case 1:ctx.moveTo(size/2,0);ctx.lineTo(-size/3,-size/2);ctx.lineTo(-size/3,size/2);ctx.closePath();break;
            case 2:
                for(let i=0;i<10;i++){
                    const a=(i/10)*Math.PI*2-Math.PI/2;
                    const r=i%2===0?size/2:size/4;
                    if(i===0)ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r);
                    else ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);
                }
                ctx.closePath();break;
            case 3:ctx.arc(0,0,size/2,0,Math.PI*2);break;
        }
        if(filled)ctx.fill();ctx.stroke();ctx.restore();
    }

    // Particles
    function spawnParticles(x,y,hue,n=12){for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2,s=0.5+Math.random()*2;particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:1,decay:0.01+Math.random()*0.015,size:1+Math.random()*2,hue:hue+Math.random()*30-15});}}
    function updateParticles(){for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;p.life-=p.decay;if(p.life<=0)particles.splice(i,1);}}
    function drawParticles(){for(const p of particles){ctx.globalAlpha=p.life*0.5;ctx.fillStyle=`hsla(${p.hue},65%,60%,1)`;ctx.beginPath();ctx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);ctx.fill();}ctx.globalAlpha=1;}

    // Background
    function drawBg(){
        const grad=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,Math.max(W,H)*0.7);
        grad.addColorStop(0,'#0a1018');grad.addColorStop(0.5,'#060c14');grad.addColorStop(1,'#030508');
        ctx.fillStyle=grad;ctx.fillRect(0,0,W,H);
        ctx.fillStyle='rgba(255,255,255,0.015)';
        const gs=50;
        for(let x=gs;x<W;x+=gs)for(let y=gs;y<H;y+=gs){ctx.beginPath();ctx.arc(x,y,0.5,0,Math.PI*2);ctx.fill();}
    }

    function drawConnections(){
        if(biomorphs.length<2)return;
        const p=biomorphs[0];
        for(let i=1;i<biomorphs.length;i++){
            const c=biomorphs[i],h=hoveredIdx===i;
            ctx.save();ctx.globalAlpha=c.alpha*(h?0.12:0.03);
            ctx.strokeStyle=h?`hsla(${c.genes[16]},55%,55%,1)`:'rgba(255,255,255,1)';
            ctx.lineWidth=h?0.8:0.4;ctx.setLineDash([3,7]);
            ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(c.x,c.y);ctx.stroke();
            ctx.setLineDash([]);ctx.restore();
        }
    }

    function drawRing(b,t){
        ctx.save();ctx.translate(b.x,b.y);ctx.globalAlpha=0.08+Math.sin(t*2)*0.03;
        ctx.strokeStyle=`hsla(${b.genes[16]},50%,55%,1)`;ctx.lineWidth=0.8;
        ctx.beginPath();ctx.arc(0,0,(50+Math.sin(t*1.5)*2)*b.scale,0,Math.PI*2);ctx.stroke();ctx.restore();
    }

    function selectSurvivor(idx){
        const b=biomorphs[idx];parentGenes=[...b.genes];generation++;
        spawnParticles(b.x,b.y,b.genes[16],18);
        flash.style.setProperty('--fx',(b.x/W*100)+'%');flash.style.setProperty('--fy',(b.y/H*100)+'%');
        flash.classList.add('active');setTimeout(()=>flash.classList.remove('active'),250);
        spawnGeneration();autoTimer=0;
    }

    function showMode(t){modeInd.textContent=t;modeInd.classList.remove('vis');void modeInd.offsetWidth;modeInd.classList.add('vis');}

    function animate(){
        time+=0.016;drawBg();
        for(const b of biomorphs)b.alpha+=(1-b.alpha)*0.05;
        drawConnections();
        if(biomorphs.length>0)drawRing(biomorphs[0],time);
        biomorphs.forEach((b,i)=>drawBiomorph(b,i===hoveredIdx));
        updateParticles();drawParticles();
        if(autoMode){autoTimer++;if(autoTimer>=AUTO_INTERVAL)selectSurvivor(Math.floor(Math.random()*8)+1);}
        requestAnimationFrame(animate);
    }

    // Input
    canvas.addEventListener('mousemove',(e)=>{
        const mx=e.clientX,my=e.clientY;hoveredIdx=-1;
        for(let i=0;i<biomorphs.length;i++){if(Math.hypot(biomorphs[i].x-mx,biomorphs[i].y-my)<65*biomorphs[i].scale){hoveredIdx=i;break;}}
        if(hoveredIdx>=0){hoverLabel.textContent=biomorphs[hoveredIdx].label;hoverLabel.style.left=(mx+14)+'px';hoverLabel.style.top=(my-18)+'px';hoverLabel.classList.add('visible');canvas.style.cursor='pointer';}
        else{hoverLabel.classList.remove('visible');canvas.style.cursor='crosshair';}
    });
    canvas.addEventListener('mousedown',()=>{if(hoveredIdx>=0){selectSurvivor(hoveredIdx);autoTimer=0;}});
    canvas.addEventListener('touchstart',(e)=>{e.preventDefault();const t=e.touches[0];for(let i=0;i<biomorphs.length;i++){if(Math.hypot(biomorphs[i].x-t.clientX,biomorphs[i].y-t.clientY)<80*biomorphs[i].scale){selectSurvivor(i);autoTimer=0;break;}}},{passive:false});

    window.addEventListener('keydown',(e)=>{
        if(e.code==='Space'){e.preventDefault();autoMode=!autoMode;document.getElementById('modeDisp').textContent=autoMode?'Auto-drift':'Manual';showMode(autoMode?'Auto-drift enabled':'Manual selection');}
        if(e.code==='KeyR'){generation=0;parentGenes=[3,25,0.0,0.85,1,4,20,1.2,0.3,2,10,1,12,0,4,8,180,15,1,2];spawnGeneration();showMode('Genome reset');}
        if(e.code==='ArrowUp'){mutRate=Math.min(0.5,mutRate+0.02);document.getElementById('mutRate').textContent=Math.round(mutRate*100)+'%';}
        if(e.code==='ArrowDown'){mutRate=Math.max(0.02,mutRate-0.02);document.getElementById('mutRate').textContent=Math.round(mutRate*100)+'%';}
    });

    window.addEventListener('resize',init);
    init();animate();
})();
</script>
</body>
</html>
